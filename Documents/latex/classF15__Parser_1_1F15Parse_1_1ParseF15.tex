\hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15}{}\doxysection{F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15 Class Reference}
\label{classF15__Parser_1_1F15Parse_1_1ParseF15}\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a9c0ccde701beda868b808f19123b95c8}{parse\+\_\+f15}} (self, ers, tokens)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a376ec629cd3c8267b213e23f0b6c022d}{add\+\_\+error\+\_\+and\+\_\+re\+\_\+sync}} (self, ers, tokens, token, error\+\_\+number)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a0e67c02918dcbfd4ce87a9d8eaa2098b}{add\+\_\+record}} (self, ers, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a5a7636a37b24407d5d2bb73bbacdcf1f}{assign\+\_\+altitude}} (self, ers, token, ex\+\_\+route\+\_\+rec, altitude\+\_\+string, cruise)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a29cabd41a76bfe9ad6983639c47dd95e}{assign\+\_\+azimuth\+\_\+distance\+\_\+between\+\_\+points}} (self, ers)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_afc516eeb23edc845beb125d3909fca4f}{assign\+\_\+lat\+\_\+long\+\_\+bearing\+\_\+distance}} (self, ers, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a13aeefb60285413d9485781e1507af69}{assign\+\_\+ll\+\_\+deg}} (self, ers, token, ex\+\_\+route\+\_\+rec, token\+\_\+string)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a7482f174106ac09820ca0aecfad97f7d}{assign\+\_\+ll\+\_\+deg\+\_\+min}} (self, ers, token, ex\+\_\+route\+\_\+rec, token\+\_\+string)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a8b98f54ad60f50ec3640395125bf03d8}{assign\+\_\+speed\+\_\+altitude}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_aed1e8a38d652cfc353d20b429fbe7c9a}{assign\+\_\+speed\+\_\+altitude\+\_\+altitude}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_abe1298e6d8138108fc73891ab5aba000}{assign\+\_\+speed\+\_\+altitude\+\_\+plus}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a1392185ee70d0ed8756d6636709da267}{assign\+\_\+speed\+\_\+vfr}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_afed5817bec3f91037230697d183a0053}{break\+\_\+end}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a9652f6181b48e3f48714f5f0c99f97de}{break\+\_\+end\+\_\+error}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a859f1d83467857effbda9469d46c4c45}{break\+\_\+start}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_ac56f5b8edd8395a4e8f7905c218cb7f0}{break\+\_\+text\+\_\+save}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_ad2e5cf0983515d0952b5ab1ef4aa5f1f}{cruise\+\_\+climb\+\_\+c}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a29140d23ca86bf7992b08da94501e85a}{cruise\+\_\+climb\+\_\+point}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a5e295c7a8ebc0b8cccb36fddb57fdf67}{dct}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a927c9dff1af69a9d2f4a45200a5a416b}{forward\+\_\+slash}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_add6607a7f5f3c3a6632c72f135753b7a}{post\+\_\+adep}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a3d17c6d784e9b84170991265d95b07a6}{post\+\_\+point}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a5ebff4c126937669f5408cfdf66b6510}{post\+\_\+sid}} (self, ers, tokens)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_ab56178e8f6f1091b58bc872020bf4d3e}{point}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a9476aa7ec48bcff3c24cb36de0c4ca2e}{resolve\+\_\+real\+\_\+bd\+\_\+point}} (self, ers, ex\+\_\+route\+\_\+rec, bearing, distance)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_ad676a053a6889ef209578acdc363fd6f}{re\+\_\+sync\+\_\+parser\+\_\+after\+\_\+error}} (self, ers, tokens)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_aa54a727a8f93fd8858c3989c98afe0e5}{route}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a1582693ea36dc4d0ab65f01c9dc35134}{sid}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a43ab56dde6cc24f1598bf28147df03ad}{sid\+\_\+star}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a59c8880b146d1f96747346d46df63496}{star}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_ae36246d517c0698b27dd1da6238fcf23}{stay}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_afc4152cee2f5f5e4a88d2ec6228552a1}{stay\+\_\+time}} (self, ers, tokens, token)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_aed2d2aab33d5f863b42278fb8cd4c902}{truncate}} (self, ers, tokens)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a8c47c48bf172e65d95917d2dffefe880}{v\+\_\+to\+\_\+i\+\_\+rule\+\_\+change}} (self, ers, tokens)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a4c5fde73ce1659f0048053fd9eb71576}{v\+\_\+to\+\_\+i\+\_\+to\+\_\+v\+\_\+rule\+\_\+change}} (self, ers, tokens)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_ae1a122a200e1fda55ba2124c5ef1b42c}{add\+\_\+error\+\_\+no\+\_\+re\+\_\+sync}} (ers, token, error\+\_\+number)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a1915a7dedc4ba004d6b836e2417069c7}{assign\+\_\+latitude}} (ex\+\_\+route\+\_\+rec, latitude)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_aa05d134ccddf0e5bd8cbfd41f84422a7}{assign\+\_\+longitude}} (ex\+\_\+route\+\_\+rec, longitude)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a322aa365f66a7e4159fb5b3dd3e62f78}{assign\+\_\+speed}} (ex\+\_\+route\+\_\+rec, speed\+\_\+string)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a1e5637a062dbf2d6e0ed23a8eb2d1113}{carry\+\_\+speed\+\_\+altitude\+\_\+rules\+\_\+forward}} (ers)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a72aa215575e0603bbb125b150c1b6895}{set\+\_\+azimuth\+\_\+and\+\_\+distance}} (point\+\_\+1, point\+\_\+2)
\item 
def \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_ad7788456d54ddde4ce528253a3ba4959}{assign\+\_\+syntax\+\_\+descriptions}} (tokens)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
string \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a58d59303946e17822706f9f9637553c4}{D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+T\+I\+T\+U\+DE}} = \char`\"{}F050\char`\"{}
\item 
dictionary \mbox{\hyperlink{classF15__Parser_1_1F15Parse_1_1ParseF15_a1212f57385394f7b405000288bdee47f}{R\+U\+L\+ES}} = \{\char`\"{}I\char`\"{}\+: \char`\"{}I\+FR\char`\"{}, \char`\"{}V\char`\"{}\+: \char`\"{}V\+FR\char`\"{}, \char`\"{}O\char`\"{}\+: \char`\"{}O\+AT\char`\"{}, \char`\"{}S\char`\"{}\+: \char`\"{}I\+F\+PS\char`\"{}\}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}This class parses an ICAO field 15 for correct syntax and semantics; an ICAO
field 15 string is tokenized by the Tokenizer class to remove all whitespace,
(spaces, newlines, carriage return and tabs).

The Tokenizer produces a list of tokens in the Tokens class; this class uses the
tokens as input to parse.

The output is stored in an instance of the ExtractedRouteRecord class that is
populated by this parser class.

The parser checks for field 15 grammar and semantics reporting errors AS
necessary.

Field 15 comprises three basic types of tokens:
    - Point: A point can be an AIP published route point, a latitude / longitude
      or a point derived from a point / bearing / distance token;
    - Connector: A connector can be an AIP ATS route designator, DCT, SID,
      STAR, rule change tokens VFR/IFR, OAT/GAT or IFPSTART/IFPSTOP.
      Connectors connect points together.
    - Modifier: A modifier is a speed and / or level change. A modifier is applied
      at a point preceding the field 15 modifier token.
This parser creates a list of points and connectors with modifiers applied at
their associated point. A complete Extracted Route Sequence always starts and ends
with the ADEP and ADES respectively, both are 'points'. The ERS contains all
intermediate points connected with one of the connector types if specified in
ICAO field 15.\end{DoxyVerb}
 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a376ec629cd3c8267b213e23f0b6c022d}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a376ec629cd3c8267b213e23f0b6c022d}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!add\_error\_and\_re\_sync@{add\_error\_and\_re\_sync}}
\index{add\_error\_and\_re\_sync@{add\_error\_and\_re\_sync}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{add\_error\_and\_re\_sync()}{add\_error\_and\_re\_sync()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+add\+\_\+error\+\_\+and\+\_\+re\+\_\+sync (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token,  }\item[{}]{error\+\_\+number }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method adds an error record to the ERS that contains a field 15 element
deemed erroneous by the parser. The parser continues to try and parse the
remainder of field 15 by calling ExtractedRouteRecord.re_sync_after_error().

:param ers: An instance of ExtractedRouteSequence class into which the erroneous token is being stored;
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: The erroneous token;
:param error_number: An integer value representing an index to an error message
       defined in the ErrorMessageDefinitions class.
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{130     \textcolor{keyword}{def }add\_error\_and\_re\_sync(self, ers, tokens, token, error\_number):}
\DoxyCodeLine{131         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token, int) -\/> None}}
\DoxyCodeLine{132         \textcolor{stringliteral}{"""This method adds an error record to the ERS that contains a field 15 element}}
\DoxyCodeLine{133 \textcolor{stringliteral}{        deemed erroneous by the parser. The parser continues to try and parse the}}
\DoxyCodeLine{134 \textcolor{stringliteral}{        remainder of field 15 by calling ExtractedRouteRecord.re\_sync\_after\_error().}}
\DoxyCodeLine{135 \textcolor{stringliteral}{}}
\DoxyCodeLine{136 \textcolor{stringliteral}{        :param ers: An instance of ExtractedRouteSequence class into which the erroneous token is being stored;}}
\DoxyCodeLine{137 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{138 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{139 \textcolor{stringliteral}{        :param token: The erroneous token;}}
\DoxyCodeLine{140 \textcolor{stringliteral}{        :param error\_number: An integer value representing an index to an error message}}
\DoxyCodeLine{141 \textcolor{stringliteral}{               defined in the ErrorMessageDefinitions class.}}
\DoxyCodeLine{142 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{143 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{144         self.add\_error\_no\_re\_sync(ers, token, error\_number)}
\DoxyCodeLine{145         self.re\_sync\_parser\_after\_error(ers, tokens)}
\DoxyCodeLine{146 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_ae1a122a200e1fda55ba2124c5ef1b42c}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_ae1a122a200e1fda55ba2124c5ef1b42c}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!add\_error\_no\_re\_sync@{add\_error\_no\_re\_sync}}
\index{add\_error\_no\_re\_sync@{add\_error\_no\_re\_sync}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{add\_error\_no\_re\_sync()}{add\_error\_no\_re\_sync()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+add\+\_\+error\+\_\+no\+\_\+re\+\_\+sync (\begin{DoxyParamCaption}\item[{}]{ers,  }\item[{}]{token,  }\item[{}]{error\+\_\+number }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyVerb}This method adds an error record to the ERS that contains a field 15 element
deemed erroneous by the parser.

:param ers: An instance of ExtractedRouteSequence class into which the erroneous token is being stored;
:param token: The erroneous token;
:param error_number: An integer value representing an index to an error message
       defined in the ErrorMessageDefinitions class.
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{148     \textcolor{keyword}{def }add\_error\_no\_re\_sync(ers, token, error\_number):}
\DoxyCodeLine{149         \textcolor{comment}{\# type: (ExtractedRouteSequence, Token, int) -\/> None}}
\DoxyCodeLine{150         \textcolor{stringliteral}{"""This method adds an error record to the ERS that contains a field 15 element}}
\DoxyCodeLine{151 \textcolor{stringliteral}{        deemed erroneous by the parser.}}
\DoxyCodeLine{152 \textcolor{stringliteral}{}}
\DoxyCodeLine{153 \textcolor{stringliteral}{        :param ers: An instance of ExtractedRouteSequence class into which the erroneous token is being stored;}}
\DoxyCodeLine{154 \textcolor{stringliteral}{        :param token: The erroneous token;}}
\DoxyCodeLine{155 \textcolor{stringliteral}{        :param error\_number: An integer value representing an index to an error message}}
\DoxyCodeLine{156 \textcolor{stringliteral}{               defined in the ErrorMessageDefinitions class.}}
\DoxyCodeLine{157 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{158 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{159         ers.add\_error(token.get\_token\_string(),}
\DoxyCodeLine{160                       token.get\_token\_start\_index(),}
\DoxyCodeLine{161                       token.get\_token\_end\_index(),}
\DoxyCodeLine{162                       token.get\_token\_base\_type(),}
\DoxyCodeLine{163                       token.get\_token\_sub\_type(),}
\DoxyCodeLine{164                       ErrorMessages.error\_messages[error\_number])}
\DoxyCodeLine{165 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a0e67c02918dcbfd4ce87a9d8eaa2098b}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a0e67c02918dcbfd4ce87a9d8eaa2098b}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!add\_record@{add\_record}}
\index{add\_record@{add\_record}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{add\_record()}{add\_record()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+add\+\_\+record (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method appends a successfully parsed field 15 element to the list of
extracted route records in an instance of the ExtractedRouteRecord class.

:param ers: An ExtractedRouteSequence class instance that this token is being appended to;
:param token: The token being saved;
:return: An instance of the ExtractedRouteRecord class representing the
 saved extracted route item derived from the token input;
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{166     \textcolor{keyword}{def }add\_record(self, ers, token):}
\DoxyCodeLine{167         \textcolor{comment}{\# type: (ExtractedRouteSequence, Token) -\/> ExtractedRouteRecord}}
\DoxyCodeLine{168         \textcolor{stringliteral}{"""This method appends a successfully parsed field 15 element to the list of}}
\DoxyCodeLine{169 \textcolor{stringliteral}{        extracted route records in an instance of the ExtractedRouteRecord class.}}
\DoxyCodeLine{170 \textcolor{stringliteral}{}}
\DoxyCodeLine{171 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance that this token is being appended to;}}
\DoxyCodeLine{172 \textcolor{stringliteral}{        :param token: The token being saved;}}
\DoxyCodeLine{173 \textcolor{stringliteral}{        :return: An instance of the ExtractedRouteRecord class representing the}}
\DoxyCodeLine{174 \textcolor{stringliteral}{                 saved extracted route item derived from the token input;}}
\DoxyCodeLine{175 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{176         ex\_route\_rec = ers.append\_element(ExtractedRouteRecord(token.get\_token\_string(),}
\DoxyCodeLine{177                                                                token.get\_token\_start\_index(),}
\DoxyCodeLine{178                                                                token.get\_token\_end\_index(),}
\DoxyCodeLine{179                                                                token.get\_token\_base\_type(),}
\DoxyCodeLine{180                                                                token.get\_token\_sub\_type()))}
\DoxyCodeLine{181         self.carry\_speed\_altitude\_rules\_forward(ers)}
\DoxyCodeLine{182         \textcolor{keywordflow}{return} ex\_route\_rec}
\DoxyCodeLine{183 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a5a7636a37b24407d5d2bb73bbacdcf1f}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a5a7636a37b24407d5d2bb73bbacdcf1f}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_altitude@{assign\_altitude}}
\index{assign\_altitude@{assign\_altitude}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_altitude()}{assign\_altitude()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+altitude (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{token,  }\item[{}]{ex\+\_\+route\+\_\+rec,  }\item[{}]{altitude\+\_\+string,  }\item[{}]{cruise }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method saves the altitude data to both the imperial and SI altitude class members of an
ERS record. All four altitude types encountered in a field 15 are converted to meters for SI
storage. The altitude types processed are:
    - 'F' Flight level
    - 'S' Standard metric level in tens of metres
    - 'A' Altitude in hundreds of feet
    - 'M' Altitude in tens of metres
The altitudes are applied to the point at which an altitude is encountered
and propagated forward until a subsequent altitude change is encountered.

:param ers: An ExtractedRouteSequence class instance that an error may
    be written to if an error is detected;
:param token: A token containing a token used to report an error if an error is detected in the token;
:param ex_route_rec: An ExtractedRouteRecord record that the altitude is written to;
:param altitude_string: An altitude as a string extracted from field 15, e.g. F350;
:param cruise: A boolean indicating if the altitude_string is part of a cruise / climb token;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{184     \textcolor{keyword}{def }assign\_altitude(self, ers, token, ex\_route\_rec, altitude\_string, cruise):}
\DoxyCodeLine{185         \textcolor{comment}{\# type: (ExtractedRouteSequence, Token, ExtractedRouteRecord, str, bool) -\/> None}}
\DoxyCodeLine{186         \textcolor{stringliteral}{"""This method saves the altitude data to both the imperial and SI altitude class members of an}}
\DoxyCodeLine{187 \textcolor{stringliteral}{        ERS record. All four altitude types encountered in a field 15 are converted to meters for SI}}
\DoxyCodeLine{188 \textcolor{stringliteral}{        storage. The altitude types processed are:}}
\DoxyCodeLine{189 \textcolor{stringliteral}{            -\/ 'F' Flight level}}
\DoxyCodeLine{190 \textcolor{stringliteral}{            -\/ 'S' Standard metric level in tens of metres}}
\DoxyCodeLine{191 \textcolor{stringliteral}{            -\/ 'A' Altitude in hundreds of feet}}
\DoxyCodeLine{192 \textcolor{stringliteral}{            -\/ 'M' Altitude in tens of metres}}
\DoxyCodeLine{193 \textcolor{stringliteral}{        The altitudes are applied to the point at which an altitude is encountered}}
\DoxyCodeLine{194 \textcolor{stringliteral}{        and propagated forward until a subsequent altitude change is encountered.}}
\DoxyCodeLine{195 \textcolor{stringliteral}{}}
\DoxyCodeLine{196 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance that an error may}}
\DoxyCodeLine{197 \textcolor{stringliteral}{                    be written to if an error is detected;}}
\DoxyCodeLine{198 \textcolor{stringliteral}{        :param token: A token containing a token used to report an error if an error is detected in the token;}}
\DoxyCodeLine{199 \textcolor{stringliteral}{        :param ex\_route\_rec: An ExtractedRouteRecord record that the altitude is written to;}}
\DoxyCodeLine{200 \textcolor{stringliteral}{        :param altitude\_string: An altitude as a string extracted from field 15, e.g. F350;}}
\DoxyCodeLine{201 \textcolor{stringliteral}{        :param cruise: A boolean indicating if the altitude\_string is part of a cruise / climb token;}}
\DoxyCodeLine{202 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{203 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{204         \textcolor{keywordflow}{if} cruise:}
\DoxyCodeLine{205             ex\_route\_rec.set\_altitude\_cruise\_to(altitude\_string)}
\DoxyCodeLine{206         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{207             ex\_route\_rec.set\_altitude(altitude\_string)}
\DoxyCodeLine{208         altitude = int(altitude\_string[1:])}
\DoxyCodeLine{209         altitude\_type = altitude\_string[0:1]}
\DoxyCodeLine{210         match altitude\_type:}
\DoxyCodeLine{211             \textcolor{comment}{\# Types 'F' and 'S' are pressure flight levels in imperial ('F') or SI ('S') units}}
\DoxyCodeLine{212             \textcolor{comment}{\# Types 'A' and 'M' are altitudes in imperial ('A') or SI ('M') units}}
\DoxyCodeLine{213             case \textcolor{stringliteral}{"A"}:}
\DoxyCodeLine{214                 \textcolor{comment}{\# A = Altitude in hundreds of feet, e.g. A045 = 4,500 feet (1,372 Meters)}}
\DoxyCodeLine{215                 altitude = (altitude * 100) * Constants.FEET\_TO\_METERS}
\DoxyCodeLine{216             case \textcolor{stringliteral}{"F"}:}
\DoxyCodeLine{217                 \textcolor{comment}{\# F = Flight Level in hundreds of feet, e.g. F350 = 35,000 feet (10,668 Meters)}}
\DoxyCodeLine{218                 \textcolor{keywordflow}{if} altitude \% 5 != 0:}
\DoxyCodeLine{219                     self.add\_error\_no\_re\_sync(ers, token, 40)}
\DoxyCodeLine{220                 altitude = (altitude * 100) * Constants.FEET\_TO\_METERS}
\DoxyCodeLine{221             case \textcolor{stringliteral}{"S"} | \textcolor{stringliteral}{"M"}:}
\DoxyCodeLine{222                 \textcolor{comment}{\# S = Flight Level in tens of meters, e.g. S1130 = 11,300 meters}}
\DoxyCodeLine{223                 \textcolor{comment}{\# M = Altitude in tens of meters, e.g. M0840 = 8,400 meters}}
\DoxyCodeLine{224                 altitude = altitude * 10}
\DoxyCodeLine{225         \textcolor{keywordflow}{if} cruise:}
\DoxyCodeLine{226             ex\_route\_rec.set\_altitude\_cruise\_to\_si(int(altitude + 0.5))}
\DoxyCodeLine{227         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{228             ex\_route\_rec.set\_altitude\_si(int(altitude + 0.5))}
\DoxyCodeLine{229 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a29cabd41a76bfe9ad6983639c47dd95e}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a29cabd41a76bfe9ad6983639c47dd95e}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_azimuth\_distance\_between\_points@{assign\_azimuth\_distance\_between\_points}}
\index{assign\_azimuth\_distance\_between\_points@{assign\_azimuth\_distance\_between\_points}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_azimuth\_distance\_between\_points()}{assign\_azimuth\_distance\_between\_points()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+azimuth\+\_\+distance\+\_\+between\+\_\+points (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method sets the bearing / distance on a point when two consecutive points are
found both with valid latitude and longitude values assigned. This method 'looks' backward
in the ERS to locate a 'previous' point with a valid latitude and longitude assigned.
Points can follow one another or be separated by a connector (e.g. such as a DCT, ATS Route etc.).

:param ers: The ERS whose last point has just been assigned a latitude / longitude;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{230     \textcolor{keyword}{def }assign\_azimuth\_distance\_between\_points(self, ers):}
\DoxyCodeLine{231         \textcolor{comment}{\# type: (ExtractedRouteSequence) -\/> None}}
\DoxyCodeLine{232         \textcolor{stringliteral}{"""This method sets the bearing / distance on a point when two consecutive points are}}
\DoxyCodeLine{233 \textcolor{stringliteral}{        found both with valid latitude and longitude values assigned. This method 'looks' backward}}
\DoxyCodeLine{234 \textcolor{stringliteral}{        in the ERS to locate a 'previous' point with a valid latitude and longitude assigned.}}
\DoxyCodeLine{235 \textcolor{stringliteral}{        Points can follow one another or be separated by a connector (e.g. such as a DCT, ATS Route etc.).}}
\DoxyCodeLine{236 \textcolor{stringliteral}{}}
\DoxyCodeLine{237 \textcolor{stringliteral}{        :param ers: The ERS whose last point has just been assigned a latitude / longitude;}}
\DoxyCodeLine{238 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{239 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{240         last\_ers = ers.get\_last\_element()}
\DoxyCodeLine{241         \textcolor{keywordflow}{if} last\_ers \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{242             \textcolor{keywordflow}{return}}
\DoxyCodeLine{243         last\_but\_one\_ers = ers.get\_previous\_to\_last\_element()}
\DoxyCodeLine{244         \textcolor{keywordflow}{if} last\_but\_one\_ers \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{245             \textcolor{keywordflow}{return}}
\DoxyCodeLine{246         \textcolor{keywordflow}{if} last\_ers.is\_lat\_long\_valid():}
\DoxyCodeLine{247             \textcolor{keywordflow}{if} last\_but\_one\_ers.is\_lat\_long\_valid():}
\DoxyCodeLine{248                 \textcolor{comment}{\# We have two consecutive points with valid Latitude / Longitude}}
\DoxyCodeLine{249                 \textcolor{comment}{\# Set azimuth and distance between the two points at the previous}}
\DoxyCodeLine{250                 \textcolor{comment}{\# point.}}
\DoxyCodeLine{251                 self.set\_azimuth\_and\_distance(last\_but\_one\_ers, last\_ers)}
\DoxyCodeLine{252             \textcolor{keywordflow}{else}:}
\DoxyCodeLine{253                 \textcolor{comment}{\# Go back one more ERS element and check if this is a point}}
\DoxyCodeLine{254                 last\_minus\_two\_ers = ers.get\_element\_at(ers.get\_number\_of\_elements()-\/3)}
\DoxyCodeLine{255                 \textcolor{keywordflow}{if} last\_minus\_two\_ers \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{256                     \textcolor{keywordflow}{return}}
\DoxyCodeLine{257                 \textcolor{keywordflow}{if} last\_minus\_two\_ers.is\_lat\_long\_valid():}
\DoxyCodeLine{258                     \textcolor{comment}{\# We have two points separated by a 'connector' element and}}
\DoxyCodeLine{259                     \textcolor{comment}{\# both points have a valid Latitude / Longitude}}
\DoxyCodeLine{260                     \textcolor{comment}{\# Set azimuth and distance between the two points}}
\DoxyCodeLine{261                     self.set\_azimuth\_and\_distance(last\_minus\_two\_ers, last\_ers)}
\DoxyCodeLine{262 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_afc516eeb23edc845beb125d3909fca4f}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_afc516eeb23edc845beb125d3909fca4f}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_lat\_long\_bearing\_distance@{assign\_lat\_long\_bearing\_distance}}
\index{assign\_lat\_long\_bearing\_distance@{assign\_lat\_long\_bearing\_distance}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_lat\_long\_bearing\_distance()}{assign\_lat\_long\_bearing\_distance()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+lat\+\_\+long\+\_\+bearing\+\_\+distance (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes a point looking for and checking the semantics for latitude / longitude
and bearing distance points. Errors are reported as they are detected; the parser does not reset when
an error is located but continues to detect any and all semantic errors for a given point. Semantic
checks ensure angles do not exceed those specified as follows:
    - Bearing Distance: Bearing angle checked that it does not exceed 360 degrees;
    - Lat/Long Degrees: Latitude degrees checked for max 90 and longitude degrees max 180 degrees;
    - Lat/Long Degrees & Minutes: Latitude degrees checked for max 90, minutes 59 and longitude
      degrees max 180, minutes 59;

:param ers: An ExtractedRouteSequence class instance that any erroneous token are saved to;
:param token: The point token being semantically checked;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{285     \textcolor{keyword}{def }assign\_lat\_long\_bearing\_distance(self, ers, token):}
\DoxyCodeLine{286         \textcolor{comment}{\# type: (ExtractedRouteSequence, Token) -\/> None}}
\DoxyCodeLine{287         \textcolor{stringliteral}{"""This method processes a point looking for and checking the semantics for latitude / longitude}}
\DoxyCodeLine{288 \textcolor{stringliteral}{        and bearing distance points. Errors are reported as they are detected; the parser does not reset when}}
\DoxyCodeLine{289 \textcolor{stringliteral}{        an error is located but continues to detect any and all semantic errors for a given point. Semantic}}
\DoxyCodeLine{290 \textcolor{stringliteral}{        checks ensure angles do not exceed those specified as follows:}}
\DoxyCodeLine{291 \textcolor{stringliteral}{            -\/ Bearing Distance: Bearing angle checked that it does not exceed 360 degrees;}}
\DoxyCodeLine{292 \textcolor{stringliteral}{            -\/ Lat/Long Degrees: Latitude degrees checked for max 90 and longitude degrees max 180 degrees;}}
\DoxyCodeLine{293 \textcolor{stringliteral}{            -\/ Lat/Long Degrees \& Minutes: Latitude degrees checked for max 90, minutes 59 and longitude}}
\DoxyCodeLine{294 \textcolor{stringliteral}{              degrees max 180, minutes 59;}}
\DoxyCodeLine{295 \textcolor{stringliteral}{}}
\DoxyCodeLine{296 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance that any erroneous token are saved to;}}
\DoxyCodeLine{297 \textcolor{stringliteral}{        :param token: The point token being semantically checked;}}
\DoxyCodeLine{298 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{299 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{300         token\_string = token.get\_token\_string()}
\DoxyCodeLine{301         sub\_type = token.get\_token\_sub\_type()}
\DoxyCodeLine{302         ex\_route\_rec = ers.get\_last\_element()}
\DoxyCodeLine{303         match sub\_type:}
\DoxyCodeLine{304             case TokenSubType.F15\_SB\_PRP\_BD:}
\DoxyCodeLine{305                 \textcolor{comment}{\# Point followed by Bearing Distance}}
\DoxyCodeLine{306                 \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} Utils.is\_degree\_semantics(token\_string[-\/6:-\/3], 360):}
\DoxyCodeLine{307                     self.add\_error\_no\_re\_sync(ers, token, 46)}
\DoxyCodeLine{308                     \textcolor{comment}{\# To populate the lat/long properly, the lat/long for the}}
\DoxyCodeLine{309                     \textcolor{comment}{\# point is needed, which we currently do not have.}}
\DoxyCodeLine{310                     \textcolor{comment}{\# Nothing to do for now.}}
\DoxyCodeLine{311             case TokenSubType.F15\_SB\_LL\_DEG:}
\DoxyCodeLine{312                 \textcolor{comment}{\# Lat/Long in Degrees}}
\DoxyCodeLine{313                 self.assign\_ll\_deg(ers, token, ex\_route\_rec, token\_string)}
\DoxyCodeLine{314             case TokenSubType.F15\_SB\_LL\_MIN:}
\DoxyCodeLine{315                 \textcolor{comment}{\# Lat/Long in Degrees and Minutes}}
\DoxyCodeLine{316                 self.assign\_ll\_deg\_min(ers, token, ex\_route\_rec, token\_string)}
\DoxyCodeLine{317             case TokenSubType.F15\_SB\_LLBD\_DEG:}
\DoxyCodeLine{318                 \textcolor{comment}{\# Lat/Long in Degrees followed Bearing Distance}}
\DoxyCodeLine{319                 self.assign\_ll\_deg(ers, token, ex\_route\_rec, token\_string)}
\DoxyCodeLine{320                 \textcolor{comment}{\# Process the bearing component}}
\DoxyCodeLine{321                 \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} Utils.is\_degree\_semantics(token\_string[-\/6:-\/3], 360):}
\DoxyCodeLine{322                     self.add\_error\_no\_re\_sync(ers, token, 46)}
\DoxyCodeLine{323                 \textcolor{comment}{\# Calculate the 'real' point from the given lat/long and the}}
\DoxyCodeLine{324                 \textcolor{comment}{\# bearing / distance.}}
\DoxyCodeLine{325                 self.resolve\_real\_bd\_point(}
\DoxyCodeLine{326                      ers, ex\_route\_rec, float(token\_string[-\/6:-\/3]), float(token\_string[-\/3:]))}
\DoxyCodeLine{327             case TokenSubType.F15\_SB\_LLBD\_MIN:}
\DoxyCodeLine{328                 \textcolor{comment}{\# Lat/Long in Degrees and Minutes followed by Bearing Distance}}
\DoxyCodeLine{329                 self.assign\_ll\_deg\_min(ers, token, ex\_route\_rec, token\_string)}
\DoxyCodeLine{330                 \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} Utils.is\_degree\_semantics(token\_string[-\/6:-\/3], 360):}
\DoxyCodeLine{331                     self.add\_error\_no\_re\_sync(ers, token, 46)}
\DoxyCodeLine{332                 \textcolor{comment}{\# Calculate the 'real' point from the given lat/long and the}}
\DoxyCodeLine{333                 \textcolor{comment}{\# bearing / distance.}}
\DoxyCodeLine{334                 self.resolve\_real\_bd\_point(}
\DoxyCodeLine{335                      ers, ex\_route\_rec, float(token\_string[-\/6:-\/3]), float(token\_string[-\/3:]))}
\DoxyCodeLine{336 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a1915a7dedc4ba004d6b836e2417069c7}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a1915a7dedc4ba004d6b836e2417069c7}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_latitude@{assign\_latitude}}
\index{assign\_latitude@{assign\_latitude}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_latitude()}{assign\_latitude()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+latitude (\begin{DoxyParamCaption}\item[{}]{ex\+\_\+route\+\_\+rec,  }\item[{}]{latitude }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyVerb}This method assigns the latitude as a decimal value to a points' latitude. The
method takes the latitude input as a string.

:param ex_route_rec: An extracted route record containing a point whose latitude
       is being set.
:param latitude: The latitude as a string; 2 characters for degrees, 4 characters
       for degrees and minutes.
:return: none
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{264     \textcolor{keyword}{def }assign\_latitude(ex\_route\_rec, latitude):}
\DoxyCodeLine{265         \textcolor{comment}{\# type: (ExtractedRouteRecord, str) -\/> None}}
\DoxyCodeLine{266         \textcolor{stringliteral}{"""This method assigns the latitude as a decimal value to a points' latitude. The}}
\DoxyCodeLine{267 \textcolor{stringliteral}{        method takes the latitude input as a string.}}
\DoxyCodeLine{268 \textcolor{stringliteral}{}}
\DoxyCodeLine{269 \textcolor{stringliteral}{        :param ex\_route\_rec: An extracted route record containing a point whose latitude}}
\DoxyCodeLine{270 \textcolor{stringliteral}{               is being set.}}
\DoxyCodeLine{271 \textcolor{stringliteral}{        :param latitude: The latitude as a string; 2 characters for degrees, 4 characters}}
\DoxyCodeLine{272 \textcolor{stringliteral}{               for degrees and minutes.}}
\DoxyCodeLine{273 \textcolor{stringliteral}{        :return: none}}
\DoxyCodeLine{274 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{275         n\_or\_s = latitude[-\/1:]}
\DoxyCodeLine{276         \textcolor{keywordflow}{if} len(latitude) < 4:}
\DoxyCodeLine{277             \textcolor{comment}{\# Degrees}}
\DoxyCodeLine{278             ex\_route\_rec.set\_latitude(float(latitude[0:2]))}
\DoxyCodeLine{279         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{280             \textcolor{comment}{\# Degrees and minutes}}
\DoxyCodeLine{281             ex\_route\_rec.set\_latitude(float(latitude[0:2]) + (float(latitude[2:4]) / 60.0))}
\DoxyCodeLine{282         \textcolor{keywordflow}{if} n\_or\_s == \textcolor{stringliteral}{"S"}:}
\DoxyCodeLine{283             ex\_route\_rec.set\_latitude(ex\_route\_rec.get\_latitude() * -\/1.0)}
\DoxyCodeLine{284 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a13aeefb60285413d9485781e1507af69}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a13aeefb60285413d9485781e1507af69}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_ll\_deg@{assign\_ll\_deg}}
\index{assign\_ll\_deg@{assign\_ll\_deg}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_ll\_deg()}{assign\_ll\_deg()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+ll\+\_\+deg (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{token,  }\item[{}]{ex\+\_\+route\+\_\+rec,  }\item[{}]{token\+\_\+string }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method takes a field 15 element representing a point defined as a latitude / longitude in
degrees (no minutes) and converts the string representation of the latitude / longitude into decimal
values and stores them in an ERS record.

The North / South and East / West indicators determine if the decimal value is negative or positive.

Errors are reported if the angular values specify incorrect semantics. Valid angles are:
    - 00 to 90 for Latitude, North indicator value is positive, South negative;
    - 000 to 180 for Longitude, East indicator value is positive, West negative;

:param ers: The complete Extracted Route Sequence (ERS);
:param token: The field 15 lat/long element being processed;
:param ex_route_rec: An ERS record into which the decimal lat/long values will
       be written;
:param token_string: The string representing an ICAO lat/long (e.g.23N123E);
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{337     \textcolor{keyword}{def }assign\_ll\_deg(self, ers, token, ex\_route\_rec, token\_string):}
\DoxyCodeLine{338         \textcolor{comment}{\# type: (ExtractedRouteSequence, Token, ExtractedRouteRecord, str) -\/> None}}
\DoxyCodeLine{339         \textcolor{stringliteral}{"""This method takes a field 15 element representing a point defined as a latitude / longitude in}}
\DoxyCodeLine{340 \textcolor{stringliteral}{        degrees (no minutes) and converts the string representation of the latitude / longitude into decimal}}
\DoxyCodeLine{341 \textcolor{stringliteral}{        values and stores them in an ERS record.}}
\DoxyCodeLine{342 \textcolor{stringliteral}{}}
\DoxyCodeLine{343 \textcolor{stringliteral}{        The North / South and East / West indicators determine if the decimal value is negative or positive.}}
\DoxyCodeLine{344 \textcolor{stringliteral}{}}
\DoxyCodeLine{345 \textcolor{stringliteral}{        Errors are reported if the angular values specify incorrect semantics. Valid angles are:}}
\DoxyCodeLine{346 \textcolor{stringliteral}{            -\/ 00 to 90 for Latitude, North indicator value is positive, South negative;}}
\DoxyCodeLine{347 \textcolor{stringliteral}{            -\/ 000 to 180 for Longitude, East indicator value is positive, West negative;}}
\DoxyCodeLine{348 \textcolor{stringliteral}{}}
\DoxyCodeLine{349 \textcolor{stringliteral}{        :param ers: The complete Extracted Route Sequence (ERS);}}
\DoxyCodeLine{350 \textcolor{stringliteral}{        :param token: The field 15 lat/long element being processed;}}
\DoxyCodeLine{351 \textcolor{stringliteral}{        :param ex\_route\_rec: An ERS record into which the decimal lat/long values will}}
\DoxyCodeLine{352 \textcolor{stringliteral}{               be written;}}
\DoxyCodeLine{353 \textcolor{stringliteral}{        :param token\_string: The string representing an ICAO lat/long (e.g.23N123E);}}
\DoxyCodeLine{354 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{355 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{356         self.assign\_latitude(ex\_route\_rec, token\_string[0:3])}
\DoxyCodeLine{357         self.assign\_longitude(ex\_route\_rec, token\_string[3:7])}
\DoxyCodeLine{358         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} Utils.is\_degree\_semantics(token\_string[0:2], 90):}
\DoxyCodeLine{359             self.add\_error\_no\_re\_sync(ers, token, 42)}
\DoxyCodeLine{360         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} Utils.is\_degree\_semantics(token\_string[3:6], 180):}
\DoxyCodeLine{361             self.add\_error\_no\_re\_sync(ers, token, 44)}
\DoxyCodeLine{362         ex\_route\_rec.set\_lat\_long\_valid(\textcolor{keyword}{True})}
\DoxyCodeLine{363         self.assign\_azimuth\_distance\_between\_points(ers)}
\DoxyCodeLine{364 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a7482f174106ac09820ca0aecfad97f7d}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a7482f174106ac09820ca0aecfad97f7d}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_ll\_deg\_min@{assign\_ll\_deg\_min}}
\index{assign\_ll\_deg\_min@{assign\_ll\_deg\_min}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_ll\_deg\_min()}{assign\_ll\_deg\_min()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+ll\+\_\+deg\+\_\+min (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{token,  }\item[{}]{ex\+\_\+route\+\_\+rec,  }\item[{}]{token\+\_\+string }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method takes a field 15 element representing a point defined as a latitude / longitude
in degrees (with minutes) and converts the string representation of the latitude / longitude into
decimal values and stores them in an ERS record.

The North / South and East / West indicators determine if the decimal value is negative or positive.

Errors are reported if the angular values specify incorrect semantics. Valid angles are:
    - 00 to 90 for Latitude, North indicator value is positive, South negative;
    - 000 to 180 for Longitude, East indicator value is positive, West negative;
    - 00 to 59 for minutes;

:param ers: The complete Extracted Route Sequence (ERS);
:param token: The field 15 lat/long element being processed;
:param ex_route_rec: An ERS record into which the decimal lat/long values will
       be written;
:param token_string: The string representing an ICAO lat/long (e.g.23N123E);
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{365     \textcolor{keyword}{def }assign\_ll\_deg\_min(self, ers, token, ex\_route\_rec, token\_string):}
\DoxyCodeLine{366         \textcolor{comment}{\# type: (ExtractedRouteSequence, Token, ExtractedRouteRecord, str) -\/> None}}
\DoxyCodeLine{367         \textcolor{stringliteral}{"""This method takes a field 15 element representing a point defined as a latitude / longitude}}
\DoxyCodeLine{368 \textcolor{stringliteral}{        in degrees (with minutes) and converts the string representation of the latitude / longitude into}}
\DoxyCodeLine{369 \textcolor{stringliteral}{        decimal values and stores them in an ERS record.}}
\DoxyCodeLine{370 \textcolor{stringliteral}{}}
\DoxyCodeLine{371 \textcolor{stringliteral}{        The North / South and East / West indicators determine if the decimal value is negative or positive.}}
\DoxyCodeLine{372 \textcolor{stringliteral}{}}
\DoxyCodeLine{373 \textcolor{stringliteral}{        Errors are reported if the angular values specify incorrect semantics. Valid angles are:}}
\DoxyCodeLine{374 \textcolor{stringliteral}{            -\/ 00 to 90 for Latitude, North indicator value is positive, South negative;}}
\DoxyCodeLine{375 \textcolor{stringliteral}{            -\/ 000 to 180 for Longitude, East indicator value is positive, West negative;}}
\DoxyCodeLine{376 \textcolor{stringliteral}{            -\/ 00 to 59 for minutes;}}
\DoxyCodeLine{377 \textcolor{stringliteral}{}}
\DoxyCodeLine{378 \textcolor{stringliteral}{        :param ers: The complete Extracted Route Sequence (ERS);}}
\DoxyCodeLine{379 \textcolor{stringliteral}{        :param token: The field 15 lat/long element being processed;}}
\DoxyCodeLine{380 \textcolor{stringliteral}{        :param ex\_route\_rec: An ERS record into which the decimal lat/long values will}}
\DoxyCodeLine{381 \textcolor{stringliteral}{               be written;}}
\DoxyCodeLine{382 \textcolor{stringliteral}{        :param token\_string: The string representing an ICAO lat/long (e.g.23N123E);}}
\DoxyCodeLine{383 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{384 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{385         self.assign\_latitude(ex\_route\_rec, token\_string[0:5])}
\DoxyCodeLine{386         self.assign\_longitude(ex\_route\_rec, token\_string[5:11])}
\DoxyCodeLine{387         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} Utils.is\_degree\_minute\_semantics(token\_string[0:4], 90, 2):}
\DoxyCodeLine{388             self.add\_error\_no\_re\_sync(ers, token, 43)}
\DoxyCodeLine{389         \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} Utils.is\_degree\_minute\_semantics(token\_string[5:10], 180, 3):}
\DoxyCodeLine{390             self.add\_error\_no\_re\_sync(ers, token, 45)}
\DoxyCodeLine{391         ex\_route\_rec.set\_lat\_long\_valid(\textcolor{keyword}{True})}
\DoxyCodeLine{392         self.assign\_azimuth\_distance\_between\_points(ers)}
\DoxyCodeLine{393 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_aa05d134ccddf0e5bd8cbfd41f84422a7}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_aa05d134ccddf0e5bd8cbfd41f84422a7}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_longitude@{assign\_longitude}}
\index{assign\_longitude@{assign\_longitude}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_longitude()}{assign\_longitude()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+longitude (\begin{DoxyParamCaption}\item[{}]{ex\+\_\+route\+\_\+rec,  }\item[{}]{longitude }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyVerb}This method assigns a floating point number to a points' longitude. The method takes the
longitude input as a string.

:param ex_route_rec: An extracted route record containing a point whose longitude
       is being set.
:param longitude: The longitude as a string; 3 characters for degrees, 5 characters
       for degrees and minutes.
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{395     \textcolor{keyword}{def }assign\_longitude(ex\_route\_rec, longitude):}
\DoxyCodeLine{396         \textcolor{comment}{\# type: (ExtractedRouteRecord, str) -\/> None}}
\DoxyCodeLine{397         \textcolor{stringliteral}{"""This method assigns a floating point number to a points' longitude. The method takes the}}
\DoxyCodeLine{398 \textcolor{stringliteral}{        longitude input as a string.}}
\DoxyCodeLine{399 \textcolor{stringliteral}{}}
\DoxyCodeLine{400 \textcolor{stringliteral}{        :param ex\_route\_rec: An extracted route record containing a point whose longitude}}
\DoxyCodeLine{401 \textcolor{stringliteral}{               is being set.}}
\DoxyCodeLine{402 \textcolor{stringliteral}{        :param longitude: The longitude as a string; 3 characters for degrees, 5 characters}}
\DoxyCodeLine{403 \textcolor{stringliteral}{               for degrees and minutes.}}
\DoxyCodeLine{404 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{405 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{406         e\_or\_w = longitude[-\/1:]}
\DoxyCodeLine{407         \textcolor{keywordflow}{if} len(longitude) < 5:}
\DoxyCodeLine{408             \textcolor{comment}{\# Degrees}}
\DoxyCodeLine{409             ex\_route\_rec.set\_longitude(float(longitude[0:3]))}
\DoxyCodeLine{410         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{411             \textcolor{comment}{\# Degrees and minutes}}
\DoxyCodeLine{412             ex\_route\_rec.set\_longitude(float(longitude[0:3]) + (float(longitude[3:5]) / 60.0))}
\DoxyCodeLine{413         \textcolor{keywordflow}{if} e\_or\_w == \textcolor{stringliteral}{"W"}:}
\DoxyCodeLine{414             ex\_route\_rec.set\_longitude(ex\_route\_rec.get\_longitude() * -\/1.0)}
\DoxyCodeLine{415 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a322aa365f66a7e4159fb5b3dd3e62f78}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a322aa365f66a7e4159fb5b3dd3e62f78}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_speed@{assign\_speed}}
\index{assign\_speed@{assign\_speed}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_speed()}{assign\_speed()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+speed (\begin{DoxyParamCaption}\item[{}]{ex\+\_\+route\+\_\+rec,  }\item[{}]{speed\+\_\+string }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyVerb}This method saves the speed data to the imperial and SI speed members of an ERS record.
All three speed types encountered in a field 15 are converted to meters / second for SI storage.
The speed types processed are:
    - 'K' Kilometres per hour
    - 'N' Knots
    - 'M' True Mach number
The speeds are applied to the point at which a speed is encountered and propagated forward until
a subsequent speed change is encountered.

Note that the Mach speed requires the altitude, hence the ERS altitude record must always be
set before determining the speed. Some field 15 elements contain only a speed (e.g. Speed / VFR).
If a Mach number is given in such elements, the speed is calculated using the speed of sound
at sea level.

:param ex_route_rec: An ExtractedRouteRecord record that the altitude is written to;
:param speed_string: A speed as a string extracted from field 15, e.g. N0450;
:return: none
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{417     \textcolor{keyword}{def }assign\_speed(ex\_route\_rec, speed\_string):}
\DoxyCodeLine{418         \textcolor{comment}{\# type: (ExtractedRouteRecord, str) -\/> None}}
\DoxyCodeLine{419         \textcolor{stringliteral}{"""This method saves the speed data to the imperial and SI speed members of an ERS record.}}
\DoxyCodeLine{420 \textcolor{stringliteral}{        All three speed types encountered in a field 15 are converted to meters / second for SI storage.}}
\DoxyCodeLine{421 \textcolor{stringliteral}{        The speed types processed are:}}
\DoxyCodeLine{422 \textcolor{stringliteral}{            -\/ 'K' Kilometres per hour}}
\DoxyCodeLine{423 \textcolor{stringliteral}{            -\/ 'N' Knots}}
\DoxyCodeLine{424 \textcolor{stringliteral}{            -\/ 'M' True Mach number}}
\DoxyCodeLine{425 \textcolor{stringliteral}{        The speeds are applied to the point at which a speed is encountered and propagated forward until}}
\DoxyCodeLine{426 \textcolor{stringliteral}{        a subsequent speed change is encountered.}}
\DoxyCodeLine{427 \textcolor{stringliteral}{}}
\DoxyCodeLine{428 \textcolor{stringliteral}{        Note that the Mach speed requires the altitude, hence the ERS altitude record must always be}}
\DoxyCodeLine{429 \textcolor{stringliteral}{        set before determining the speed. Some field 15 elements contain only a speed (e.g. Speed / VFR).}}
\DoxyCodeLine{430 \textcolor{stringliteral}{        If a Mach number is given in such elements, the speed is calculated using the speed of sound}}
\DoxyCodeLine{431 \textcolor{stringliteral}{        at sea level.}}
\DoxyCodeLine{432 \textcolor{stringliteral}{}}
\DoxyCodeLine{433 \textcolor{stringliteral}{        :param ex\_route\_rec: An ExtractedRouteRecord record that the altitude is written to;}}
\DoxyCodeLine{434 \textcolor{stringliteral}{        :param speed\_string: A speed as a string extracted from field 15, e.g. N0450;}}
\DoxyCodeLine{435 \textcolor{stringliteral}{        :return: none}}
\DoxyCodeLine{436 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{437         ex\_route\_rec.set\_speed(speed\_string)}
\DoxyCodeLine{438 }
\DoxyCodeLine{439         \textcolor{comment}{\# Need the altitude in meters for Mach calculation}}
\DoxyCodeLine{440         altitude\_si = ex\_route\_rec.get\_altitude\_si()}
\DoxyCodeLine{441         speed = int(speed\_string[1:])}
\DoxyCodeLine{442         speed\_type = speed\_string[0:1]}
\DoxyCodeLine{443         match speed\_type:}
\DoxyCodeLine{444             case \textcolor{stringliteral}{"K"}:}
\DoxyCodeLine{445                 \textcolor{comment}{\# Kilometers / hour}}
\DoxyCodeLine{446                 speed = speed * Constants.KMH\_TO\_METERS\_SECOND}
\DoxyCodeLine{447             case \textcolor{stringliteral}{"N"}:}
\DoxyCodeLine{448                 \textcolor{comment}{\# Knots}}
\DoxyCodeLine{449                 speed = speed * Constants.KNOTS\_TO\_METERS\_SECOND}
\DoxyCodeLine{450             case \textcolor{stringliteral}{"M"}:}
\DoxyCodeLine{451                 speed = Utils.mach\_to\_ms\_speed(speed, altitude\_si)}
\DoxyCodeLine{452         ex\_route\_rec.set\_speed\_si(int(speed + 0.5))}
\DoxyCodeLine{453 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a8b98f54ad60f50ec3640395125bf03d8}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a8b98f54ad60f50ec3640395125bf03d8}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_speed\_altitude@{assign\_speed\_altitude}}
\index{assign\_speed\_altitude@{assign\_speed\_altitude}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_speed\_altitude()}{assign\_speed\_altitude()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+speed\+\_\+altitude (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes a speed / altitude element, (e.g. N0450F350). A speed / altitude element
is always preceded by a point, hence the speed and altitude are applied to the preceding point
which is the last ERS record.

Note that the altitude must be assigned in meters to the ERS before the speed as the speed given
as a Mach number uses the altitude to calculate a speed.

:param ers: An ExtractedRouteSequence class instance containing a point in
       the last ERS record that the speed and altitude will be written to;
:param tokens: A list of tokens extracted from field 15 used as input to the parser.
       This structure contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: The speed / altitude token from which the speed and altitude will
       be extracted from;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{454     \textcolor{keyword}{def }assign\_speed\_altitude(self, ers, tokens, token):}
\DoxyCodeLine{455         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{456         \textcolor{stringliteral}{"""This method processes a speed / altitude element, (e.g. N0450F350). A speed / altitude element}}
\DoxyCodeLine{457 \textcolor{stringliteral}{        is always preceded by a point, hence the speed and altitude are applied to the preceding point}}
\DoxyCodeLine{458 \textcolor{stringliteral}{        which is the last ERS record.}}
\DoxyCodeLine{459 \textcolor{stringliteral}{}}
\DoxyCodeLine{460 \textcolor{stringliteral}{        Note that the altitude must be assigned in meters to the ERS before the speed as the speed given}}
\DoxyCodeLine{461 \textcolor{stringliteral}{        as a Mach number uses the altitude to calculate a speed.}}
\DoxyCodeLine{462 \textcolor{stringliteral}{}}
\DoxyCodeLine{463 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing a point in}}
\DoxyCodeLine{464 \textcolor{stringliteral}{               the last ERS record that the speed and altitude will be written to;}}
\DoxyCodeLine{465 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser.}}
\DoxyCodeLine{466 \textcolor{stringliteral}{               This structure contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{467 \textcolor{stringliteral}{        :param token: The speed / altitude token from which the speed and altitude will}}
\DoxyCodeLine{468 \textcolor{stringliteral}{               be extracted from;}}
\DoxyCodeLine{469 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{470 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{471         ex\_route\_rec = ers.get\_last\_element()}
\DoxyCodeLine{472         \textcolor{keywordflow}{if} ex\_route\_rec \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{473             \textcolor{keywordflow}{return}}
\DoxyCodeLine{474         token\_string = token.get\_token\_string()}
\DoxyCodeLine{475         sub\_type = token.get\_token\_sub\_type()}
\DoxyCodeLine{476         match sub\_type:}
\DoxyCodeLine{477             case TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MS | \(\backslash\)}
\DoxyCodeLine{478                  TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MM:}
\DoxyCodeLine{479                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[4:], \textcolor{keyword}{False})}
\DoxyCodeLine{480                 self.assign\_speed(ex\_route\_rec, token\_string[0:4])}
\DoxyCodeLine{481             case TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KS | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KA | \(\backslash\)}
\DoxyCodeLine{482                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KM | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NS | \(\backslash\)}
\DoxyCodeLine{483                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NM | \(\backslash\)}
\DoxyCodeLine{484                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NF:}
\DoxyCodeLine{485                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[5:], \textcolor{keyword}{False})}
\DoxyCodeLine{486                 self.assign\_speed(ex\_route\_rec, token\_string[0:5])}
\DoxyCodeLine{487             case \_:}
\DoxyCodeLine{488                 self.assign\_altitude(ers, token, ex\_route\_rec, \textcolor{stringliteral}{"X000"}, \textcolor{keyword}{False})}
\DoxyCodeLine{489                 self.assign\_speed(ex\_route\_rec, \textcolor{stringliteral}{"X0000"})}
\DoxyCodeLine{490                 \textcolor{keywordflow}{return}}
\DoxyCodeLine{491 }
\DoxyCodeLine{492         \textcolor{comment}{\# As this is a speed altitude element, the rules must be IFR}}
\DoxyCodeLine{493         ex\_route\_rec.set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"I"}])}
\DoxyCodeLine{494 }
\DoxyCodeLine{495         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{496         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{497             \textcolor{keywordflow}{return}}
\DoxyCodeLine{498 }
\DoxyCodeLine{499         \textcolor{comment}{\# If there is only one ERS record it has to be the ADEP record, i.e. the}}
\DoxyCodeLine{500         \textcolor{comment}{\# next token is the first element following the first SPEED / LEVEL}}
\DoxyCodeLine{501         \textcolor{comment}{\# element. Otherwise, we are processing an element after a SPEED / LEVEL}}
\DoxyCodeLine{502         \textcolor{comment}{\# somewhere else in field 15.}}
\DoxyCodeLine{503         \textcolor{keywordflow}{if} ers.get\_number\_of\_elements() == 1:}
\DoxyCodeLine{504             self.post\_adep(ers, tokens, next\_token)}
\DoxyCodeLine{505         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{506             \textcolor{comment}{\# Go to post point processing as a rule change to IFR is terminated}}
\DoxyCodeLine{507             \textcolor{comment}{\# with a point}}
\DoxyCodeLine{508             self.post\_point(ers, tokens, next\_token)}
\DoxyCodeLine{509 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_aed1e8a38d652cfc353d20b429fbe7c9a}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_aed1e8a38d652cfc353d20b429fbe7c9a}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_speed\_altitude\_altitude@{assign\_speed\_altitude\_altitude}}
\index{assign\_speed\_altitude\_altitude@{assign\_speed\_altitude\_altitude}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_speed\_altitude\_altitude()}{assign\_speed\_altitude\_altitude()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+speed\+\_\+altitude\+\_\+altitude (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes the speed / altitude / altitude part of a cruise climb element.
A speed / altitude / altitude element is always preceded by a point, hence the speed and altitude
are applied to the preceding point which is the last ERS record.

:param ers: An ExtractedRouteSequence class instance containing a point in
       the last ERS record that the speed and altitude will be written to.
:param tokens: A list of tokens extracted from field 15 used as input to the parser.
       This structure contains a tokenized form of all field 15 tokens used as
       input to this parser.
:param token: The speed / altitude token from which the speed and altitude will
       be extracted from;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{510     \textcolor{keyword}{def }assign\_speed\_altitude\_altitude(self, ers, tokens, token):}
\DoxyCodeLine{511         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{512         \textcolor{stringliteral}{"""This method processes the speed / altitude / altitude part of a cruise climb element.}}
\DoxyCodeLine{513 \textcolor{stringliteral}{        A speed / altitude / altitude element is always preceded by a point, hence the speed and altitude}}
\DoxyCodeLine{514 \textcolor{stringliteral}{        are applied to the preceding point which is the last ERS record.}}
\DoxyCodeLine{515 \textcolor{stringliteral}{}}
\DoxyCodeLine{516 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing a point in}}
\DoxyCodeLine{517 \textcolor{stringliteral}{               the last ERS record that the speed and altitude will be written to.}}
\DoxyCodeLine{518 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser.}}
\DoxyCodeLine{519 \textcolor{stringliteral}{               This structure contains a tokenized form of all field 15 tokens used as}}
\DoxyCodeLine{520 \textcolor{stringliteral}{               input to this parser.}}
\DoxyCodeLine{521 \textcolor{stringliteral}{        :param token: The speed / altitude token from which the speed and altitude will}}
\DoxyCodeLine{522 \textcolor{stringliteral}{               be extracted from;}}
\DoxyCodeLine{523 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{524 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{525         ex\_route\_rec = ers.get\_last\_element()}
\DoxyCodeLine{526         \textcolor{keywordflow}{if} ex\_route\_rec \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{527             \textcolor{keywordflow}{return}}
\DoxyCodeLine{528         token\_string = token.get\_token\_string()}
\DoxyCodeLine{529         sub\_type = token.get\_token\_sub\_type()}
\DoxyCodeLine{530         match sub\_type:}
\DoxyCodeLine{531             case TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KFF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KFS | \(\backslash\)}
\DoxyCodeLine{532                  TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KFA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KFM | \(\backslash\)}
\DoxyCodeLine{533                  TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KAF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KAS | \(\backslash\)}
\DoxyCodeLine{534                  TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KAA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KAM | \(\backslash\)}
\DoxyCodeLine{535                  TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NFF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NFS | \(\backslash\)}
\DoxyCodeLine{536                  TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NFA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NFM | \(\backslash\)}
\DoxyCodeLine{537                  TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NAF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NAS | \(\backslash\)}
\DoxyCodeLine{538                  TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NAA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NAM:}
\DoxyCodeLine{539                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[5:9], \textcolor{keyword}{False})}
\DoxyCodeLine{540                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[9:], \textcolor{keyword}{True})}
\DoxyCodeLine{541                 self.assign\_speed(ex\_route\_rec, token\_string[0:5])}
\DoxyCodeLine{542             case TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KSF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KSS | \(\backslash\)}
\DoxyCodeLine{543                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KSA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KSM | \(\backslash\)}
\DoxyCodeLine{544                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KMF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KMS | \(\backslash\)}
\DoxyCodeLine{545                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KMA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KMM | \(\backslash\)}
\DoxyCodeLine{546                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NSF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NSS | \(\backslash\)}
\DoxyCodeLine{547                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NSA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NSM | \(\backslash\)}
\DoxyCodeLine{548                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NMF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NMS | \(\backslash\)}
\DoxyCodeLine{549                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NMA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NMM:}
\DoxyCodeLine{550                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[5:10], \textcolor{keyword}{False})}
\DoxyCodeLine{551                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[11:], \textcolor{keyword}{True})}
\DoxyCodeLine{552                 self.assign\_speed(ex\_route\_rec, token\_string[0:5])}
\DoxyCodeLine{553             case TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MFF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MFS | \(\backslash\)}
\DoxyCodeLine{554                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MFA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MFM | \(\backslash\)}
\DoxyCodeLine{555                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MAF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MAS | \(\backslash\)}
\DoxyCodeLine{556                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MAA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MAM:}
\DoxyCodeLine{557                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[4:8], \textcolor{keyword}{False})}
\DoxyCodeLine{558                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[9:], \textcolor{keyword}{True})}
\DoxyCodeLine{559                 self.assign\_speed(ex\_route\_rec, token\_string[0:4])}
\DoxyCodeLine{560             case TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MSF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MSS | \(\backslash\)}
\DoxyCodeLine{561                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MSA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MSM | \(\backslash\)}
\DoxyCodeLine{562                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MMF | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MMS | \(\backslash\)}
\DoxyCodeLine{563                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MMA | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MMM:}
\DoxyCodeLine{564                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[4:9], \textcolor{keyword}{False})}
\DoxyCodeLine{565                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[10:], \textcolor{keyword}{True})}
\DoxyCodeLine{566                 self.assign\_speed(ex\_route\_rec, token\_string[0:4])}
\DoxyCodeLine{567             case \_:}
\DoxyCodeLine{568                 self.assign\_altitude(ers, token, ex\_route\_rec, \textcolor{stringliteral}{"X000"}, \textcolor{keyword}{False})}
\DoxyCodeLine{569                 self.assign\_speed(ex\_route\_rec, \textcolor{stringliteral}{"X000"})}
\DoxyCodeLine{570                 \textcolor{keywordflow}{return}}
\DoxyCodeLine{571 }
\DoxyCodeLine{572         \textcolor{comment}{\# As this is a speed altitude element, the rules must be IFR}}
\DoxyCodeLine{573         ex\_route\_rec.set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"I"}])}
\DoxyCodeLine{574 }
\DoxyCodeLine{575         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{576         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{577             \textcolor{keywordflow}{return}}
\DoxyCodeLine{578 }
\DoxyCodeLine{579         self.post\_point(ers, tokens, next\_token)}
\DoxyCodeLine{580 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_abe1298e6d8138108fc73891ab5aba000}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_abe1298e6d8138108fc73891ab5aba000}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_speed\_altitude\_plus@{assign\_speed\_altitude\_plus}}
\index{assign\_speed\_altitude\_plus@{assign\_speed\_altitude\_plus}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_speed\_altitude\_plus()}{assign\_speed\_altitude\_plus()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+speed\+\_\+altitude\+\_\+plus (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes the speed / altitude / plus part of a cruise climb element.
A speed / altitude / plus element is always preceded by a point, hence the speed and altitude
are applied to the preceding point which is the last ERS record.

:param ers: An ExtractedRouteSequence class instance containing a point in
       the last ERS record that the speed and altitude will be written to.
:param tokens: A list of tokens extracted from field 15 used as input to the parser.
       This structure contains a tokenized form of all field 15 tokens used as
       input to this parser.
:param token: The speed / altitude token from which the speed and altitude will
       be extracted from;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{581     \textcolor{keyword}{def }assign\_speed\_altitude\_plus(self, ers, tokens, token):}
\DoxyCodeLine{582         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{583         \textcolor{stringliteral}{"""This method processes the speed / altitude / plus part of a cruise climb element.}}
\DoxyCodeLine{584 \textcolor{stringliteral}{        A speed / altitude / plus element is always preceded by a point, hence the speed and altitude}}
\DoxyCodeLine{585 \textcolor{stringliteral}{        are applied to the preceding point which is the last ERS record.}}
\DoxyCodeLine{586 \textcolor{stringliteral}{}}
\DoxyCodeLine{587 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing a point in}}
\DoxyCodeLine{588 \textcolor{stringliteral}{               the last ERS record that the speed and altitude will be written to.}}
\DoxyCodeLine{589 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser.}}
\DoxyCodeLine{590 \textcolor{stringliteral}{               This structure contains a tokenized form of all field 15 tokens used as}}
\DoxyCodeLine{591 \textcolor{stringliteral}{               input to this parser.}}
\DoxyCodeLine{592 \textcolor{stringliteral}{        :param token: The speed / altitude token from which the speed and altitude will}}
\DoxyCodeLine{593 \textcolor{stringliteral}{               be extracted from;}}
\DoxyCodeLine{594 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{595 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{596         ex\_route\_rec = ers.get\_last\_element()}
\DoxyCodeLine{597         \textcolor{keywordflow}{if} ex\_route\_rec \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{598             \textcolor{keywordflow}{return}}
\DoxyCodeLine{599         token\_string = token.get\_token\_string()}
\DoxyCodeLine{600         sub\_type = token.get\_token\_sub\_type()}
\DoxyCodeLine{601         match sub\_type:}
\DoxyCodeLine{602             case TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KF\_P | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KA\_P | \(\backslash\)}
\DoxyCodeLine{603                  TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NF\_P | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NA\_P:}
\DoxyCodeLine{604                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[5:9], \textcolor{keyword}{False})}
\DoxyCodeLine{605                 ex\_route\_rec.set\_altitude\_cruise\_to(token\_string[9:])}
\DoxyCodeLine{606                 self.assign\_speed(ex\_route\_rec, token\_string[0:5])}
\DoxyCodeLine{607             case TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KS\_P | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KM\_P | \(\backslash\)}
\DoxyCodeLine{608                     TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NS\_P | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NM\_P:}
\DoxyCodeLine{609                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[5:10], \textcolor{keyword}{False})}
\DoxyCodeLine{610                 ex\_route\_rec.set\_altitude\_cruise\_to(token\_string[10:])}
\DoxyCodeLine{611                 self.assign\_speed(ex\_route\_rec, token\_string[0:5])}
\DoxyCodeLine{612             case TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MF\_P | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MA\_P:}
\DoxyCodeLine{613                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[4:8], \textcolor{keyword}{False})}
\DoxyCodeLine{614                 ex\_route\_rec.set\_altitude\_cruise\_to(token\_string[8:])}
\DoxyCodeLine{615                 self.assign\_speed(ex\_route\_rec, token\_string[0:4])}
\DoxyCodeLine{616             case TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MS\_P | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MM\_P:}
\DoxyCodeLine{617                 self.assign\_altitude(ers, token, ex\_route\_rec, token\_string[4:9], \textcolor{keyword}{False})}
\DoxyCodeLine{618                 ex\_route\_rec.set\_altitude\_cruise\_to(token\_string[9:])}
\DoxyCodeLine{619                 self.assign\_speed(ex\_route\_rec, token\_string[0:4])}
\DoxyCodeLine{620             case \_:}
\DoxyCodeLine{621                 self.assign\_altitude(ers, token, ex\_route\_rec, \textcolor{stringliteral}{"X000"}, \textcolor{keyword}{False})}
\DoxyCodeLine{622                 self.assign\_speed(ex\_route\_rec, \textcolor{stringliteral}{"X000"})}
\DoxyCodeLine{623                 \textcolor{keywordflow}{return}}
\DoxyCodeLine{624 }
\DoxyCodeLine{625         \textcolor{comment}{\# As this is a speed altitude element, the rules must be IFR}}
\DoxyCodeLine{626         ex\_route\_rec.set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"I"}])}
\DoxyCodeLine{627 }
\DoxyCodeLine{628         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{629         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{630             \textcolor{keywordflow}{return}}
\DoxyCodeLine{631 }
\DoxyCodeLine{632         self.post\_point(ers, tokens, next\_token)}
\DoxyCodeLine{633 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a1392185ee70d0ed8756d6636709da267}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a1392185ee70d0ed8756d6636709da267}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_speed\_vfr@{assign\_speed\_vfr}}
\index{assign\_speed\_vfr@{assign\_speed\_vfr}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_speed\_vfr()}{assign\_speed\_vfr()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+speed\+\_\+vfr (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method precess a speed / VFR element. The element preceding a SPEED/VFR token must be
a point, hence we have to set the speed at the previous point and assign VFR rules at a new
ERS record to store the rule change VFR record.

:param ers: An ExtractedRouteSequence class instance containing a point in the last ERS record
       that the speed will be written to and a new VFR record will be appended to.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: The speed / VFR token from which the speed will be extracted from;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{634     \textcolor{keyword}{def }assign\_speed\_vfr(self, ers, tokens, token):}
\DoxyCodeLine{635         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{636         \textcolor{stringliteral}{"""This method precess a speed / VFR element. The element preceding a SPEED/VFR token must be}}
\DoxyCodeLine{637 \textcolor{stringliteral}{        a point, hence we have to set the speed at the previous point and assign VFR rules at a new}}
\DoxyCodeLine{638 \textcolor{stringliteral}{        ERS record to store the rule change VFR record.}}
\DoxyCodeLine{639 \textcolor{stringliteral}{}}
\DoxyCodeLine{640 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing a point in the last ERS record}}
\DoxyCodeLine{641 \textcolor{stringliteral}{               that the speed will be written to and a new VFR record will be appended to.}}
\DoxyCodeLine{642 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{643 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{644 \textcolor{stringliteral}{        :param token: The speed / VFR token from which the speed will be extracted from;}}
\DoxyCodeLine{645 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{646 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{647         \textcolor{comment}{\# Get the last ERS record which will be a point at which the VFR}}
\DoxyCodeLine{648         \textcolor{comment}{\# rule change is taking place.}}
\DoxyCodeLine{649         point\_ex\_route\_rec = ers.get\_last\_element()}
\DoxyCodeLine{650         \textcolor{keywordflow}{if} point\_ex\_route\_rec \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{651             \textcolor{keywordflow}{return}}
\DoxyCodeLine{652 }
\DoxyCodeLine{653         \textcolor{comment}{\# Create a copy of the SPEED/VFR token and change the name to 'VFR'}}
\DoxyCodeLine{654         vfr\_token = copy.deepcopy(token)}
\DoxyCodeLine{655         vfr\_token.set\_token\_string(\textcolor{stringliteral}{"VFR"})}
\DoxyCodeLine{656         ex\_route\_rec = self.add\_record(ers, vfr\_token)}
\DoxyCodeLine{657 }
\DoxyCodeLine{658         \textcolor{comment}{\# Assign a default altitude as none is given in a SPEED/VFR element}}
\DoxyCodeLine{659         self.assign\_altitude(ers, token, ex\_route\_rec, self.DEFAULT\_ALTITUDE, \textcolor{keyword}{False})}
\DoxyCodeLine{660 }
\DoxyCodeLine{661         token\_string = token.get\_token\_string()}
\DoxyCodeLine{662         sub\_type = token.get\_token\_sub\_type()}
\DoxyCodeLine{663         match sub\_type:}
\DoxyCodeLine{664             case TokenBaseType.F15\_SPEED\_VFR | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_MV:}
\DoxyCodeLine{665                 self.assign\_speed(ex\_route\_rec, token\_string[0:4])}
\DoxyCodeLine{666                 ex\_route\_rec.set\_flight\_rules(self.RULES[token\_string[4:5]])}
\DoxyCodeLine{667             case TokenBaseType.F15\_SPEED\_VFR | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_NV | \(\backslash\)}
\DoxyCodeLine{668                     TokenBaseType.F15\_SPEED\_VFR | TokenSubType.F15\_SB\_SPEED\_ALTITUDE\_KV:}
\DoxyCodeLine{669                 self.assign\_speed(ex\_route\_rec, token\_string[0:5])}
\DoxyCodeLine{670                 ex\_route\_rec.set\_flight\_rules(self.RULES[token\_string[5:6]])}
\DoxyCodeLine{671             case \_:}
\DoxyCodeLine{672                 self.assign\_altitude(ers, token, ex\_route\_rec, \textcolor{stringliteral}{"X000"}, \textcolor{keyword}{False})}
\DoxyCodeLine{673                 ex\_route\_rec.set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"I"}])}
\DoxyCodeLine{674 }
\DoxyCodeLine{675         \textcolor{comment}{\# Copy the speed and altitude from the VFR record to the VFR rule change point}}
\DoxyCodeLine{676         point\_ex\_route\_rec.set\_speed(ex\_route\_rec.get\_speed())}
\DoxyCodeLine{677         point\_ex\_route\_rec.set\_speed\_si(ex\_route\_rec.get\_speed\_si())}
\DoxyCodeLine{678         point\_ex\_route\_rec.set\_altitude(ex\_route\_rec.get\_altitude())}
\DoxyCodeLine{679         point\_ex\_route\_rec.set\_altitude\_si(ex\_route\_rec.get\_altitude\_si())}
\DoxyCodeLine{680 }
\DoxyCodeLine{681         token = tokens.get\_next\_token()}
\DoxyCodeLine{682         \textcolor{keywordflow}{if} token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{683             \textcolor{keywordflow}{return}}
\DoxyCodeLine{684         self.break\_text\_save(ers, tokens, token)}
\DoxyCodeLine{685 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_ad7788456d54ddde4ce528253a3ba4959}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_ad7788456d54ddde4ce528253a3ba4959}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!assign\_syntax\_descriptions@{assign\_syntax\_descriptions}}
\index{assign\_syntax\_descriptions@{assign\_syntax\_descriptions}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{assign\_syntax\_descriptions()}{assign\_syntax\_descriptions()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+assign\+\_\+syntax\+\_\+descriptions (\begin{DoxyParamCaption}\item[{}]{tokens }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyVerb}This method loops over all the tokens produced by the Tokenizer and assigns a token base and
subtype to each token. The type definitions are obtained from the definitions in the
'F15TokenSyntaxDescriptions' class.
:param tokens: The tokens being looped over having their base and subtypes assigned;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1690     \textcolor{keyword}{def }assign\_syntax\_descriptions(tokens):}
\DoxyCodeLine{1691         \textcolor{comment}{\# type: (Tokens) -\/> None}}
\DoxyCodeLine{1692         \textcolor{stringliteral}{""" This method loops over all the tokens produced by the Tokenizer and assigns a token base and}}
\DoxyCodeLine{1693 \textcolor{stringliteral}{        subtype to each token. The type definitions are obtained from the definitions in the}}
\DoxyCodeLine{1694 \textcolor{stringliteral}{        'F15TokenSyntaxDescriptions' class.}}
\DoxyCodeLine{1695 \textcolor{stringliteral}{        :param tokens: The tokens being looped over having their base and subtypes assigned;}}
\DoxyCodeLine{1696 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1697 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1698         f15tsa = F15TokenSyntaxDefinition()}
\DoxyCodeLine{1699         \textcolor{keywordflow}{for} token \textcolor{keywordflow}{in} tokens.get\_tokens():}
\DoxyCodeLine{1700             token\_string = token.get\_token\_string()}
\DoxyCodeLine{1701             result = f15tsa.get\_token\_type(token\_string)}
\DoxyCodeLine{1702             token.set\_token\_base\_type(result[F15TokenSyntaxDefinition.TOKEN\_BASE\_IDENTIFIER\_IDX])}
\DoxyCodeLine{1703             token.set\_token\_sub\_type(result[F15TokenSyntaxDefinition.TOKEN\_SUBTYPE\_IDENTIFIER\_IDX])}
\DoxyCodeLine{1704             \textcolor{keywordflow}{if} len(token\_string) > F15TokenSyntaxDefinition.MAX\_TOKEN\_LENGTH:}
\DoxyCodeLine{1705                 token.set\_token\_base\_type(TokenBaseType.F15\_TOO\_LONG)}
\DoxyCodeLine{1706                 token.set\_token\_sub\_type(TokenSubType.F15\_SB\_UNKNOWN)}

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_afed5817bec3f91037230697d183a0053}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_afed5817bec3f91037230697d183a0053}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!break\_end@{break\_end}}
\index{break\_end@{break\_end}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{break\_end()}{break\_end()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+break\+\_\+end (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method is processing a 'break' end token, one of 'IFR', 'GAT' or 'IFPSTART'. A 'break' is
considered to be a break in IFR routing, i.e. a change from IFR to VFR and back to IFR has a 'break'
between two IFR sections. Any tokens appearing between the end of the first IFR section and the
start of the second IFR section are stored on the intermediate VFR (or OAT, IFPSTOP) section token,
(referred to as break text).

If the end of a break section is NOT occurring then control is returned to saving these tokens as
'break' text. All break text ends must be followed by a point. The IFR end must be further followed
by a point/speed/altitude or point/speed/vfr element. As a rule change is terminated by a point,
control is handed to the point node for further processing.

:param ers: An ExtractedRouteSequence class instance containing a start break token, (one of VFR,
       OAT or IFPSTOP) in the last ERS record that the break text will be written to, or if the
       'break' is determined then the change back to IFR will be appended to the ERS.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: The 'break' end token, ('IFR', 'GAT' or 'IFPSTART' token indicating the end of 'break';
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{686     \textcolor{keyword}{def }break\_end(self, ers, tokens, token):}
\DoxyCodeLine{687         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{688         \textcolor{stringliteral}{"""This method is processing a 'break' end token, one of 'IFR', 'GAT' or 'IFPSTART'. A 'break' is}}
\DoxyCodeLine{689 \textcolor{stringliteral}{        considered to be a break in IFR routing, i.e. a change from IFR to VFR and back to IFR has a 'break'}}
\DoxyCodeLine{690 \textcolor{stringliteral}{        between two IFR sections. Any tokens appearing between the end of the first IFR section and the}}
\DoxyCodeLine{691 \textcolor{stringliteral}{        start of the second IFR section are stored on the intermediate VFR (or OAT, IFPSTOP) section token,}}
\DoxyCodeLine{692 \textcolor{stringliteral}{        (referred to as break text).}}
\DoxyCodeLine{693 \textcolor{stringliteral}{}}
\DoxyCodeLine{694 \textcolor{stringliteral}{        If the end of a break section is NOT occurring then control is returned to saving these tokens as}}
\DoxyCodeLine{695 \textcolor{stringliteral}{        'break' text. All break text ends must be followed by a point. The IFR end must be further followed}}
\DoxyCodeLine{696 \textcolor{stringliteral}{        by a point/speed/altitude or point/speed/vfr element. As a rule change is terminated by a point,}}
\DoxyCodeLine{697 \textcolor{stringliteral}{        control is handed to the point node for further processing.}}
\DoxyCodeLine{698 \textcolor{stringliteral}{}}
\DoxyCodeLine{699 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing a start break token, (one of VFR,}}
\DoxyCodeLine{700 \textcolor{stringliteral}{               OAT or IFPSTOP) in the last ERS record that the break text will be written to, or if the}}
\DoxyCodeLine{701 \textcolor{stringliteral}{               'break' is determined then the change back to IFR will be appended to the ERS.}}
\DoxyCodeLine{702 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{703 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{704 \textcolor{stringliteral}{        :param token: The 'break' end token, ('IFR', 'GAT' or 'IFPSTART' token indicating the end of 'break';}}
\DoxyCodeLine{705 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{706 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{707         \textcolor{comment}{\# Get what should be a point following the IFR, GAT or IFPSTART element}}
\DoxyCodeLine{708         rule\_change\_point = tokens.peek\_next\_token(1)}
\DoxyCodeLine{709         \textcolor{keywordflow}{if} rule\_change\_point \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{710             \textcolor{comment}{\# Nothing following the rule change token}}
\DoxyCodeLine{711             \textcolor{keywordflow}{return}}
\DoxyCodeLine{712         \textcolor{keywordflow}{if} rule\_change\_point.get\_token\_base\_type() != TokenBaseType.F15\_POINT:}
\DoxyCodeLine{713             \textcolor{comment}{\# Element following rule change is not a point}}
\DoxyCodeLine{714             \textcolor{keywordflow}{return}}
\DoxyCodeLine{715 }
\DoxyCodeLine{716         \textcolor{comment}{\# Process rule change according to type of rule change}}
\DoxyCodeLine{717         sub\_type = token.get\_token\_sub\_type()}
\DoxyCodeLine{718         \textcolor{keywordflow}{if} sub\_type == TokenSubType.F15\_SB\_IFR:}
\DoxyCodeLine{719 }
\DoxyCodeLine{720             \textcolor{comment}{\# Get the '/' following the point}}
\DoxyCodeLine{721             slash\_token = tokens.peek\_next\_token(2)}
\DoxyCodeLine{722             \textcolor{keywordflow}{if} slash\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{723                 \textcolor{comment}{\# End of field 15, no further processing, rule change incomplete}}
\DoxyCodeLine{724                 self.add\_error\_and\_re\_sync(ers, tokens, rule\_change\_point, 22)}
\DoxyCodeLine{725                 \textcolor{keywordflow}{return}}
\DoxyCodeLine{726             \textcolor{keywordflow}{if} slash\_token.get\_token\_base\_type() != TokenBaseType.F15\_SLASH:}
\DoxyCodeLine{727                 \textcolor{comment}{\# Not a slash, we can assume no rule change is taking place.}}
\DoxyCodeLine{728                 \textcolor{comment}{\# We can bale out of rule change processing}}
\DoxyCodeLine{729                 \textcolor{keywordflow}{return}}
\DoxyCodeLine{730 }
\DoxyCodeLine{731             \textcolor{comment}{\# Get the SPEED / LEVEL following the '/'}}
\DoxyCodeLine{732             speed\_level\_token = tokens.peek\_next\_token(3)}
\DoxyCodeLine{733             \textcolor{keywordflow}{if} speed\_level\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{734                 \textcolor{comment}{\# End of field 15, no further processing, rule change incomplete}}
\DoxyCodeLine{735                 self.add\_error\_and\_re\_sync(ers, tokens, rule\_change\_point, 22)}
\DoxyCodeLine{736                 \textcolor{keywordflow}{return}}
\DoxyCodeLine{737             \textcolor{keywordflow}{if} speed\_level\_token.get\_token\_base\_type() != TokenBaseType.F15\_SPEED\_ALTITUDE \textcolor{keywordflow}{and} \(\backslash\)}
\DoxyCodeLine{738                     speed\_level\_token.get\_token\_base\_type() != TokenBaseType.F15\_SPEED\_VFR:}
\DoxyCodeLine{739                 \textcolor{comment}{\# Not a SPEED / LEVEL, we can assume no rule change is taking place}}
\DoxyCodeLine{740                 \textcolor{comment}{\# We can bale out of rule change processing, the tokens 'peeked' in}}
\DoxyCodeLine{741                 \textcolor{comment}{\# this method will be saved as break text by the calling function.}}
\DoxyCodeLine{742                 self.add\_error\_and\_re\_sync(ers, tokens, rule\_change\_point, 22)}
\DoxyCodeLine{743                 \textcolor{keywordflow}{return}}
\DoxyCodeLine{744 }
\DoxyCodeLine{745             \textcolor{comment}{\# All tokens indicating a rule change are present and correct,}}
\DoxyCodeLine{746             \textcolor{comment}{\# action the rule change.}}
\DoxyCodeLine{747             \textcolor{keywordflow}{if} speed\_level\_token.get\_token\_base\_type() == TokenBaseType.F15\_SPEED\_ALTITUDE:}
\DoxyCodeLine{748                 self.v\_to\_i\_rule\_change(ers, tokens)}
\DoxyCodeLine{749             \textcolor{keywordflow}{elif} speed\_level\_token.get\_token\_base\_type() == TokenBaseType.F15\_SPEED\_VFR:}
\DoxyCodeLine{750                 self.v\_to\_i\_to\_v\_rule\_change(ers, tokens)}
\DoxyCodeLine{751 }
\DoxyCodeLine{752         \textcolor{comment}{\# If we arrive here we are dealing with a rule change from OAT to GAT or}}
\DoxyCodeLine{753         \textcolor{comment}{\# IFPSTOP to IFPSTART, hence we can process the point as any other point.}}
\DoxyCodeLine{754         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{755         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{756             \textcolor{keywordflow}{return}}
\DoxyCodeLine{757         self.point(ers, tokens, next\_token)}
\DoxyCodeLine{758 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a9652f6181b48e3f48714f5f0c99f97de}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a9652f6181b48e3f48714f5f0c99f97de}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!break\_end\_error@{break\_end\_error}}
\index{break\_end\_error@{break\_end\_error}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{break\_end\_error()}{break\_end\_error()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+break\+\_\+end\+\_\+error (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method reports an error if the end of a 'break' section does not match a 'break' start token.
A 'break' is considered to be a break in IFR routing, i.e. a change from IFR to VFR and back to IFR
has a 'break' between two IFR sections. Break sections are indicated by start/end matching pairs VFR/IFR,
OAT/GAT, IFPSTOP/IFPSTART. Erroneous case are, e.g. a VFR break started and now a GAT 'break' end is
detected, hence the start and end indicators do not form part of a matching 'break' indicator pair.

:param ers: An ExtractedRouteSequence class instance containing a point token in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: The 'break' end token, ('IFR', 'GAT' or 'IFPSTART') token indicating the start of
       'break' section;
:return:
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{759     \textcolor{keyword}{def }break\_end\_error(self, ers, tokens, token):}
\DoxyCodeLine{760         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{761         \textcolor{stringliteral}{"""This method reports an error if the end of a 'break' section does not match a 'break' start token.}}
\DoxyCodeLine{762 \textcolor{stringliteral}{        A 'break' is considered to be a break in IFR routing, i.e. a change from IFR to VFR and back to IFR}}
\DoxyCodeLine{763 \textcolor{stringliteral}{        has a 'break' between two IFR sections. Break sections are indicated by start/end matching pairs VFR/IFR,}}
\DoxyCodeLine{764 \textcolor{stringliteral}{        OAT/GAT, IFPSTOP/IFPSTART. Erroneous case are, e.g. a VFR break started and now a GAT 'break' end is}}
\DoxyCodeLine{765 \textcolor{stringliteral}{        detected, hence the start and end indicators do not form part of a matching 'break' indicator pair.}}
\DoxyCodeLine{766 \textcolor{stringliteral}{}}
\DoxyCodeLine{767 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing a point token in the last ERS record.}}
\DoxyCodeLine{768 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{769 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{770 \textcolor{stringliteral}{        :param token: The 'break' end token, ('IFR', 'GAT' or 'IFPSTART') token indicating the start of}}
\DoxyCodeLine{771 \textcolor{stringliteral}{               'break' section;}}
\DoxyCodeLine{772 \textcolor{stringliteral}{        :return:}}
\DoxyCodeLine{773 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{774         subtype = token.get\_token\_sub\_type()}
\DoxyCodeLine{775         \textcolor{keywordflow}{if} subtype \textcolor{keywordflow}{is} TokenSubType.F15\_SB\_IFR:}
\DoxyCodeLine{776             self.add\_error\_and\_re\_sync(ers, tokens, token, 6)}
\DoxyCodeLine{777         \textcolor{keywordflow}{elif} subtype \textcolor{keywordflow}{is} TokenSubType.F15\_SB\_GAT:}
\DoxyCodeLine{778             self.add\_error\_and\_re\_sync(ers, tokens, token, 7)}
\DoxyCodeLine{779         \textcolor{keywordflow}{elif} subtype \textcolor{keywordflow}{is} TokenSubType.F15\_SB\_IFPSTART:}
\DoxyCodeLine{780             self.add\_error\_and\_re\_sync(ers, tokens, token, 8)}
\DoxyCodeLine{781 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a859f1d83467857effbda9469d46c4c45}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a859f1d83467857effbda9469d46c4c45}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!break\_start@{break\_start}}
\index{break\_start@{break\_start}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{break\_start()}{break\_start()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+break\+\_\+start (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method is processing the elements 'OAT', IFPSTOP', or 'VFR' all of which indicate the
start of non-IFR routing, a 'break' section. A 'break' is considered to be a break in IFR routing,
i.e. a change from IFR to VFR and back to IFR has a 'break' between two IFR sections. The ERS last
element is a point at which the 'break' section starts. The start 'break' token will be appended
to the ERS and one of the following flight rules set on the start 'break' token:
    - OAT: Rules set to 'O'
    - VFR: Rules set to 'V'
    - IFPSTOP: Rules set to 'S'
The rule change token is saved to the ERS and the rules are set on this token.

:param ers: An ExtractedRouteSequence class instance containing a point token in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: The 'break' start token, ('VFR', 'OAT' or 'IFPSTOP' token indicating
       the start of 'break' section;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{782     \textcolor{keyword}{def }break\_start(self, ers, tokens, token):}
\DoxyCodeLine{783         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{784         \textcolor{stringliteral}{"""This method is processing the elements 'OAT', IFPSTOP', or 'VFR' all of which indicate the}}
\DoxyCodeLine{785 \textcolor{stringliteral}{        start of non-\/IFR routing, a 'break' section. A 'break' is considered to be a break in IFR routing,}}
\DoxyCodeLine{786 \textcolor{stringliteral}{        i.e. a change from IFR to VFR and back to IFR has a 'break' between two IFR sections. The ERS last}}
\DoxyCodeLine{787 \textcolor{stringliteral}{        element is a point at which the 'break' section starts. The start 'break' token will be appended}}
\DoxyCodeLine{788 \textcolor{stringliteral}{        to the ERS and one of the following flight rules set on the start 'break' token:}}
\DoxyCodeLine{789 \textcolor{stringliteral}{            -\/ OAT: Rules set to 'O'}}
\DoxyCodeLine{790 \textcolor{stringliteral}{            -\/ VFR: Rules set to 'V'}}
\DoxyCodeLine{791 \textcolor{stringliteral}{            -\/ IFPSTOP: Rules set to 'S'}}
\DoxyCodeLine{792 \textcolor{stringliteral}{        The rule change token is saved to the ERS and the rules are set on this token.}}
\DoxyCodeLine{793 \textcolor{stringliteral}{}}
\DoxyCodeLine{794 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing a point token in the last ERS record.}}
\DoxyCodeLine{795 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{796 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{797 \textcolor{stringliteral}{        :param token: The 'break' start token, ('VFR', 'OAT' or 'IFPSTOP' token indicating}}
\DoxyCodeLine{798 \textcolor{stringliteral}{               the start of 'break' section;}}
\DoxyCodeLine{799 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{800 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{801         self.add\_record(ers, token)}
\DoxyCodeLine{802         ex\_route\_rec = ers.get\_last\_element()}
\DoxyCodeLine{803         sub\_type = token.get\_token\_sub\_type()}
\DoxyCodeLine{804         match sub\_type:}
\DoxyCodeLine{805             case TokenSubType.F15\_SB\_OAT:}
\DoxyCodeLine{806                 ex\_route\_rec.set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"O"}])}
\DoxyCodeLine{807             case TokenSubType.F15\_SB\_VFR:}
\DoxyCodeLine{808                 ex\_route\_rec.set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"V"}])}
\DoxyCodeLine{809             case TokenSubType.F15\_SB\_IFPSTOP:}
\DoxyCodeLine{810                 ex\_route\_rec.set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"S"}])}
\DoxyCodeLine{811 }
\DoxyCodeLine{812         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{813         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{814             \textcolor{keywordflow}{return}}
\DoxyCodeLine{815         base\_type = next\_token.get\_token\_base\_type()}
\DoxyCodeLine{816         \textcolor{keywordflow}{if} base\_type \textcolor{keywordflow}{is} TokenBaseType.F15\_TOO\_LONG:}
\DoxyCodeLine{817             self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 4)}
\DoxyCodeLine{818         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{819             self.break\_text\_save(ers, tokens, next\_token)}
\DoxyCodeLine{820 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_ac56f5b8edd8395a4e8f7905c218cb7f0}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_ac56f5b8edd8395a4e8f7905c218cb7f0}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!break\_text\_save@{break\_text\_save}}
\index{break\_text\_save@{break\_text\_save}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{break\_text\_save()}{break\_text\_save()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+break\+\_\+text\+\_\+save (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method loops over elements saving them as 'break' text; break text follows the 'break'
start tokens VFR, OAT or IFPSTOP. A 'break' is considered to be a break in IFR routing, i.e. a
change from IFR to VFR and back to IFR has a 'break' between two IFR sections.

Once a 'break' end element is detected, processing takes place to ascertain if a 'break' section
is being correctly terminated; if not, this method continues to save the tokens as 'text' on the
'break' start token. If there is a possible 'break' end detected control is passed to self.break_end().

:param ers: An ExtractedRouteSequence class instance containing a 'break' start token in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: The 'break' text token being saved to the 'break' start token;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{821     \textcolor{keyword}{def }break\_text\_save(self, ers, tokens, token):}
\DoxyCodeLine{822         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{823         \textcolor{stringliteral}{"""This method loops over elements saving them as 'break' text; break text follows the 'break'}}
\DoxyCodeLine{824 \textcolor{stringliteral}{        start tokens VFR, OAT or IFPSTOP. A 'break' is considered to be a break in IFR routing, i.e. a}}
\DoxyCodeLine{825 \textcolor{stringliteral}{        change from IFR to VFR and back to IFR has a 'break' between two IFR sections.}}
\DoxyCodeLine{826 \textcolor{stringliteral}{}}
\DoxyCodeLine{827 \textcolor{stringliteral}{        Once a 'break' end element is detected, processing takes place to ascertain if a 'break' section}}
\DoxyCodeLine{828 \textcolor{stringliteral}{        is being correctly terminated; if not, this method continues to save the tokens as 'text' on the}}
\DoxyCodeLine{829 \textcolor{stringliteral}{        'break' start token. If there is a possible 'break' end detected control is passed to self.break\_end().}}
\DoxyCodeLine{830 \textcolor{stringliteral}{}}
\DoxyCodeLine{831 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing a 'break' start token in the last ERS record.}}
\DoxyCodeLine{832 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{833 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{834 \textcolor{stringliteral}{        :param token: The 'break' text token being saved to the 'break' start token;}}
\DoxyCodeLine{835 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{836 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{837         base\_type = token.get\_token\_base\_type()}
\DoxyCodeLine{838         \textcolor{keywordflow}{if} base\_type \textcolor{keywordflow}{is} TokenBaseType.F15\_TOO\_LONG:}
\DoxyCodeLine{839             self.add\_error\_and\_re\_sync(ers, tokens, token, 4)}
\DoxyCodeLine{840 }
\DoxyCodeLine{841         \textcolor{comment}{\# Save the token as break text}}
\DoxyCodeLine{842         last\_ers = ers.get\_last\_element()}
\DoxyCodeLine{843         last\_ers.append\_break\_text(token.get\_token\_string())}
\DoxyCodeLine{844 }
\DoxyCodeLine{845         sub\_type = token.get\_token\_sub\_type()}
\DoxyCodeLine{846         cur\_break\_type = ers.get\_last\_element().get\_flight\_rules()}
\DoxyCodeLine{847 }
\DoxyCodeLine{848         \textcolor{comment}{\# Break text processing is terminated on a rule change back to IFR. If}}
\DoxyCodeLine{849         \textcolor{comment}{\# the token being processed in this method indicates the end of a break}}
\DoxyCodeLine{850         \textcolor{comment}{\# section (i.e. for VFR -\/> IFR, for OAT -\/> GAT or for IFPSTOP -\/> IFPSTART)}}
\DoxyCodeLine{851         \textcolor{comment}{\# processing is handed off to check if a valid rule change is in fact occurring.}}
\DoxyCodeLine{852         \textcolor{comment}{\# Also have to check that the break end matches the break start type before}}
\DoxyCodeLine{853         \textcolor{comment}{\# jumping out to try and end the break section}}
\DoxyCodeLine{854         \textcolor{keywordflow}{if} sub\_type \textcolor{keywordflow}{is} TokenSubType.F15\_SB\_IFR \textcolor{keywordflow}{and} cur\_break\_type \textcolor{keywordflow}{is} self.RULES[\textcolor{stringliteral}{"V"}]:}
\DoxyCodeLine{855             \textcolor{comment}{\# Possible change to IFR from VFR}}
\DoxyCodeLine{856             self.break\_end(ers, tokens, token)}
\DoxyCodeLine{857         \textcolor{keywordflow}{elif} sub\_type \textcolor{keywordflow}{is} TokenSubType.F15\_SB\_GAT \textcolor{keywordflow}{and} cur\_break\_type \textcolor{keywordflow}{is} self.RULES[\textcolor{stringliteral}{"O"}]:}
\DoxyCodeLine{858             \textcolor{comment}{\# Possible change to GAT from OAT}}
\DoxyCodeLine{859             self.break\_end(ers, tokens, token)}
\DoxyCodeLine{860         \textcolor{keywordflow}{elif} sub\_type \textcolor{keywordflow}{is} TokenSubType.F15\_SB\_IFPSTART \textcolor{keywordflow}{and} cur\_break\_type \textcolor{keywordflow}{is} self.RULES[\textcolor{stringliteral}{"S"}]:}
\DoxyCodeLine{861             \textcolor{comment}{\# Possible change to IFPSTOP from IFPSTART}}
\DoxyCodeLine{862             self.break\_end(ers, tokens, token)}
\DoxyCodeLine{863 }
\DoxyCodeLine{864         \textcolor{comment}{\# Recurse with the next token}}
\DoxyCodeLine{865         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{866         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{867             \textcolor{keywordflow}{return}}
\DoxyCodeLine{868         self.break\_text\_save(ers, tokens, next\_token)}
\DoxyCodeLine{869 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a1e5637a062dbf2d6e0ed23a8eb2d1113}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a1e5637a062dbf2d6e0ed23a8eb2d1113}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!carry\_speed\_altitude\_rules\_forward@{carry\_speed\_altitude\_rules\_forward}}
\index{carry\_speed\_altitude\_rules\_forward@{carry\_speed\_altitude\_rules\_forward}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{carry\_speed\_altitude\_rules\_forward()}{carry\_speed\_altitude\_rules\_forward()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+carry\+\_\+speed\+\_\+altitude\+\_\+rules\+\_\+forward (\begin{DoxyParamCaption}\item[{}]{ers }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyVerb}This method copies the speed, altitude and flight rules from the 'previous' ERS token to the
'current' (last) ERS token.

:param ers: An ExtractedRouteSequence class instance containing the last ERS record that has to have
       its speed, altitude and flight rule attributes copied from the penultimate ERS record to the last
       record.
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{871     \textcolor{keyword}{def }carry\_speed\_altitude\_rules\_forward(ers):}
\DoxyCodeLine{872         \textcolor{comment}{\# type: (ExtractedRouteSequence) -\/> None}}
\DoxyCodeLine{873         \textcolor{stringliteral}{"""This method copies the speed, altitude and flight rules from the 'previous' ERS token to the}}
\DoxyCodeLine{874 \textcolor{stringliteral}{        'current' (last) ERS token.}}
\DoxyCodeLine{875 \textcolor{stringliteral}{}}
\DoxyCodeLine{876 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing the last ERS record that has to have}}
\DoxyCodeLine{877 \textcolor{stringliteral}{               its speed, altitude and flight rule attributes copied from the penultimate ERS record to the last}}
\DoxyCodeLine{878 \textcolor{stringliteral}{               record.}}
\DoxyCodeLine{879 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{880 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{881         current\_ex\_route\_rec = ers.get\_last\_element()}
\DoxyCodeLine{882         previous\_ex\_route\_rec = ers.get\_previous\_to\_last\_element()}
\DoxyCodeLine{883         current\_ex\_route\_rec.set\_altitude(previous\_ex\_route\_rec.get\_altitude())}
\DoxyCodeLine{884         current\_ex\_route\_rec.set\_altitude\_si(previous\_ex\_route\_rec.get\_altitude\_si())}
\DoxyCodeLine{885         current\_ex\_route\_rec.set\_speed(previous\_ex\_route\_rec.get\_speed())}
\DoxyCodeLine{886         current\_ex\_route\_rec.set\_speed\_si(previous\_ex\_route\_rec.get\_speed\_si())}
\DoxyCodeLine{887         current\_ex\_route\_rec.set\_flight\_rules(previous\_ex\_route\_rec.get\_flight\_rules())}
\DoxyCodeLine{888 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_ad2e5cf0983515d0952b5ab1ef4aa5f1f}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_ad2e5cf0983515d0952b5ab1ef4aa5f1f}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!cruise\_climb\_c@{cruise\_climb\_c}}
\index{cruise\_climb\_c@{cruise\_climb\_c}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{cruise\_climb\_c()}{cruise\_climb\_c()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+cruise\+\_\+climb\+\_\+c (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes the 'C' token that indicates a cruise climb element may be present. If the
token following the 'C' is a '/' then we assume a cruise climb token has been located, in such a
case, the 'C' is not stored in the ERS. If the token following 'C' is not a '/' then the 'C' is
considered to be a single character point and stored in the ERS as a point.

:param ers: An ExtractedRouteSequence class instance containing a 'break' start token in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure contains
       a tokenized form of all field 15 tokens used as input to this parser.
:param token: The 'break' text token being saved to the 'break' start token;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{889     \textcolor{keyword}{def }cruise\_climb\_c(self, ers, tokens, token):}
\DoxyCodeLine{890         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{891         \textcolor{stringliteral}{"""This method processes the 'C' token that indicates a cruise climb element may be present. If the}}
\DoxyCodeLine{892 \textcolor{stringliteral}{        token following the 'C' is a '/' then we assume a cruise climb token has been located, in such a}}
\DoxyCodeLine{893 \textcolor{stringliteral}{        case, the 'C' is not stored in the ERS. If the token following 'C' is not a '/' then the 'C' is}}
\DoxyCodeLine{894 \textcolor{stringliteral}{        considered to be a single character point and stored in the ERS as a point.}}
\DoxyCodeLine{895 \textcolor{stringliteral}{}}
\DoxyCodeLine{896 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing a 'break' start token in the last ERS record.}}
\DoxyCodeLine{897 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure contains}}
\DoxyCodeLine{898 \textcolor{stringliteral}{               a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{899 \textcolor{stringliteral}{        :param token: The 'break' text token being saved to the 'break' start token;}}
\DoxyCodeLine{900 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{901 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{902         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{903         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{904             \textcolor{comment}{\# Store the 'C' as a point}}
\DoxyCodeLine{905             self.add\_record(ers, token)}
\DoxyCodeLine{906             \textcolor{keywordflow}{return}}
\DoxyCodeLine{907         base\_type = next\_token.get\_token\_base\_type()}
\DoxyCodeLine{908         match base\_type:}
\DoxyCodeLine{909             case TokenBaseType.F15\_UNKNOWN:}
\DoxyCodeLine{910                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 3)}
\DoxyCodeLine{911             case TokenBaseType.F15\_SLASH:}
\DoxyCodeLine{912                 \textcolor{comment}{\# '/' found next, assume cruise climb}}
\DoxyCodeLine{913                 \textcolor{comment}{\# Next token should be a point}}
\DoxyCodeLine{914                 slash\_token = next\_token}
\DoxyCodeLine{915                 next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{916                 \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{917                     \textcolor{comment}{\# No further tokens, Store the 'C' as a point}}
\DoxyCodeLine{918                     self.add\_record(ers, token)}
\DoxyCodeLine{919                     \textcolor{comment}{\# Report error, only have C/, should be more}}
\DoxyCodeLine{920                     self.add\_error\_and\_re\_sync(ers, tokens, slash\_token, 52)}
\DoxyCodeLine{921                     \textcolor{keywordflow}{return}}
\DoxyCodeLine{922                 \textcolor{comment}{\# Process the cruise climb point}}
\DoxyCodeLine{923                 self.cruise\_climb\_point(ers, tokens, next\_token)}
\DoxyCodeLine{924             case TokenBaseType.F15\_BREAK\_START:}
\DoxyCodeLine{925                 self.add\_record(ers, token)}
\DoxyCodeLine{926                 self.break\_start(ers, tokens, next\_token)}
\DoxyCodeLine{927             case TokenBaseType.F15\_SPEED\_VFR | TokenBaseType.F15\_SPEED\_ALTITUDE:}
\DoxyCodeLine{928                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 5)}
\DoxyCodeLine{929             case TokenBaseType.F15\_BREAK\_END:}
\DoxyCodeLine{930                 self.break\_end\_error(ers, tokens, next\_token)}
\DoxyCodeLine{931             case TokenBaseType.F15\_DCT:}
\DoxyCodeLine{932                 self.add\_record(ers, token)}
\DoxyCodeLine{933                 self.dct(ers, tokens, next\_token)}
\DoxyCodeLine{934             case TokenBaseType.F15\_STAY:}
\DoxyCodeLine{935                 self.add\_record(ers, token)}
\DoxyCodeLine{936                 self.stay(ers, tokens, next\_token)}
\DoxyCodeLine{937             case TokenBaseType.F15\_TRUNCATE:}
\DoxyCodeLine{938                 self.add\_record(ers, token)}
\DoxyCodeLine{939                 self.truncate(ers, tokens)}
\DoxyCodeLine{940             case TokenBaseType.F15\_C:}
\DoxyCodeLine{941                 self.add\_record(ers, token)}
\DoxyCodeLine{942                 self.cruise\_climb\_c(ers, tokens, next\_token)}
\DoxyCodeLine{943             case TokenBaseType.F15\_POINT:}
\DoxyCodeLine{944                 self.add\_record(ers, token)}
\DoxyCodeLine{945                 self.point(ers, tokens, next\_token)}
\DoxyCodeLine{946             case TokenBaseType.F15\_ROUTE:}
\DoxyCodeLine{947                 self.add\_record(ers, token)}
\DoxyCodeLine{948                 self.route(ers, tokens, next\_token)}
\DoxyCodeLine{949             case TokenBaseType.F15\_SID\_STAR:}
\DoxyCodeLine{950                 self.add\_record(ers, token)}
\DoxyCodeLine{951                 self.sid\_star(ers, tokens, next\_token)}
\DoxyCodeLine{952             case TokenBaseType.F15\_SPEED\_ALTITUDE\_ALTITUDE | TokenBaseType.F15\_SPEED\_ALTITUDE\_PLUS:}
\DoxyCodeLine{953                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 9)}
\DoxyCodeLine{954             case TokenBaseType.F15\_TOO\_LONG:}
\DoxyCodeLine{955                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 4)}
\DoxyCodeLine{956             case TokenBaseType.F15\_STAY\_TIME:}
\DoxyCodeLine{957                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 10)}
\DoxyCodeLine{958             case TokenBaseType.F15\_SID:}
\DoxyCodeLine{959                 self.add\_record(ers, token)}
\DoxyCodeLine{960                 self.sid(ers, tokens, next\_token)}
\DoxyCodeLine{961             case TokenBaseType.F15\_STAR:}
\DoxyCodeLine{962                 self.add\_record(ers, token)}
\DoxyCodeLine{963                 self.star(ers, tokens, next\_token)}
\DoxyCodeLine{964             case \_:}
\DoxyCodeLine{965                 self.add\_error\_and\_re\_sync(ers, tokens, token, 0)}
\DoxyCodeLine{966 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a29140d23ca86bf7992b08da94501e85a}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a29140d23ca86bf7992b08da94501e85a}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!cruise\_climb\_point@{cruise\_climb\_point}}
\index{cruise\_climb\_point@{cruise\_climb\_point}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{cruise\_climb\_point()}{cruise\_climb\_point()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+cruise\+\_\+climb\+\_\+point (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes the point in a cruise/climb element.

:param ers: An ExtractedRouteSequence class instance containing an IFR routing element in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: The point in a cruise/climb element;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{967     \textcolor{keyword}{def }cruise\_climb\_point(self, ers, tokens, token):}
\DoxyCodeLine{968         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{969         \textcolor{stringliteral}{"""This method processes the point in a cruise/climb element.}}
\DoxyCodeLine{970 \textcolor{stringliteral}{}}
\DoxyCodeLine{971 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing an IFR routing element in the last ERS record.}}
\DoxyCodeLine{972 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{973 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{974 \textcolor{stringliteral}{        :param token: The point in a cruise/climb element;}}
\DoxyCodeLine{975 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{976 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{977         \textcolor{comment}{\# Save the cruise / climb point}}
\DoxyCodeLine{978         self.add\_record(ers, token)}
\DoxyCodeLine{979 }
\DoxyCodeLine{980         \textcolor{comment}{\# Check the point semantics for Lat/Long, bearing distance points}}
\DoxyCodeLine{981         self.assign\_lat\_long\_bearing\_distance(ers, token)}
\DoxyCodeLine{982 }
\DoxyCodeLine{983         \textcolor{comment}{\# Get the next token which should be a forward slash '/'}}
\DoxyCodeLine{984         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{985         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{986             self.add\_error\_and\_re\_sync(ers, tokens, token, 27)}
\DoxyCodeLine{987             \textcolor{keywordflow}{return}}
\DoxyCodeLine{988         base\_type = next\_token.get\_token\_base\_type()}
\DoxyCodeLine{989         \textcolor{keywordflow}{if} base\_type \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} TokenBaseType.F15\_SLASH:}
\DoxyCodeLine{990             self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 26)}
\DoxyCodeLine{991 }
\DoxyCodeLine{992         \textcolor{comment}{\# Skip the forward slash and get the SPEED/ALTITUDE/ALTITUDE or}}
\DoxyCodeLine{993         \textcolor{comment}{\# SPEED / ALTITUDE / PLUS token}}
\DoxyCodeLine{994         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{995         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{996             self.add\_error\_and\_re\_sync(ers, tokens, token, 28)}
\DoxyCodeLine{997             \textcolor{keywordflow}{return}}
\DoxyCodeLine{998         base\_type = next\_token.get\_token\_base\_type()}
\DoxyCodeLine{999 }
\DoxyCodeLine{1000         \textcolor{comment}{\# Apply the cruise climb speed and altitude values}}
\DoxyCodeLine{1001         \textcolor{keywordflow}{if} base\_type \textcolor{keywordflow}{is} TokenBaseType.F15\_SPEED\_ALTITUDE\_ALTITUDE:}
\DoxyCodeLine{1002             self.assign\_speed\_altitude\_altitude(ers, tokens, next\_token)}
\DoxyCodeLine{1003         \textcolor{keywordflow}{elif} base\_type \textcolor{keywordflow}{is} TokenBaseType.F15\_SPEED\_ALTITUDE\_PLUS:}
\DoxyCodeLine{1004             self.assign\_speed\_altitude\_plus(ers, tokens, next\_token)}
\DoxyCodeLine{1005         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{1006             self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 29)}
\DoxyCodeLine{1007 }
\DoxyCodeLine{1008         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{1009         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1010             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1011         self.point(ers, tokens, next\_token)}
\DoxyCodeLine{1012 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a5e295c7a8ebc0b8cccb36fddb57fdf67}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a5e295c7a8ebc0b8cccb36fddb57fdf67}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!dct@{dct}}
\index{dct@{dct}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{dct()}{dct()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+dct (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes a DCT element.

:param ers: An ExtractedRouteSequence class instance containing an IFR routing point element in the
       last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: The DCT element;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1013     \textcolor{keyword}{def }dct(self, ers, tokens, token):}
\DoxyCodeLine{1014         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{1015         \textcolor{stringliteral}{"""This method processes a DCT element.}}
\DoxyCodeLine{1016 \textcolor{stringliteral}{}}
\DoxyCodeLine{1017 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing an IFR routing point element in the}}
\DoxyCodeLine{1018 \textcolor{stringliteral}{               last ERS record.}}
\DoxyCodeLine{1019 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1020 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1021 \textcolor{stringliteral}{        :param token: The DCT element;}}
\DoxyCodeLine{1022 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1023 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1024         self.add\_record(ers, token)}
\DoxyCodeLine{1025         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{1026         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1027             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1028         base\_type = next\_token.get\_token\_base\_type()}
\DoxyCodeLine{1029         match base\_type:}
\DoxyCodeLine{1030             case TokenBaseType.F15\_TRUNCATE:}
\DoxyCodeLine{1031                 self.truncate(ers, tokens)}
\DoxyCodeLine{1032             case TokenBaseType.F15\_POINT:}
\DoxyCodeLine{1033                 self.point(ers, tokens, next\_token)}
\DoxyCodeLine{1034             case TokenBaseType.F15\_C:}
\DoxyCodeLine{1035                 self.cruise\_climb\_c(ers, tokens, next\_token)}
\DoxyCodeLine{1036             case \_:}
\DoxyCodeLine{1037                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 21)}
\DoxyCodeLine{1038 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a927c9dff1af69a9d2f4a45200a5a416b}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a927c9dff1af69a9d2f4a45200a5a416b}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!forward\_slash@{forward\_slash}}
\index{forward\_slash@{forward\_slash}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{forward\_slash()}{forward\_slash()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+forward\+\_\+slash (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes a '/' token; the '/' character is not stored in the ERS. The method looks
for tokens following the '/' as there are only certain element types allowed to follow a '/', namely
speed/vfr, speed/altitude, truncate indicator point or route. All other element types are incorrect
resulting in an error being reported.

:param ers: An ExtractedRouteSequence class instance containing an IFR point element in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure contains
       a tokenized form of all field 15 tokens used as input to this parser.
:param token: The '/' token;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1039     \textcolor{keyword}{def }forward\_slash(self, ers, tokens, token):}
\DoxyCodeLine{1040         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{1041         \textcolor{stringliteral}{"""This method processes a '/' token; the '/' character is not stored in the ERS. The method looks}}
\DoxyCodeLine{1042 \textcolor{stringliteral}{        for tokens following the '/' as there are only certain element types allowed to follow a '/', namely}}
\DoxyCodeLine{1043 \textcolor{stringliteral}{        speed/vfr, speed/altitude, truncate indicator point or route. All other element types are incorrect}}
\DoxyCodeLine{1044 \textcolor{stringliteral}{        resulting in an error being reported.}}
\DoxyCodeLine{1045 \textcolor{stringliteral}{}}
\DoxyCodeLine{1046 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing an IFR point element in the last ERS record.}}
\DoxyCodeLine{1047 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure contains}}
\DoxyCodeLine{1048 \textcolor{stringliteral}{               a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1049 \textcolor{stringliteral}{        :param token: The '/' token;}}
\DoxyCodeLine{1050 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1051 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1052         \textcolor{comment}{\# Don't save the '/' and get next token}}
\DoxyCodeLine{1053         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{1054         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1055             self.add\_error\_and\_re\_sync(ers, tokens, token, 20)}
\DoxyCodeLine{1056             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1057         base\_type = next\_token.get\_token\_base\_type()}
\DoxyCodeLine{1058         match base\_type:}
\DoxyCodeLine{1059             case TokenBaseType.F15\_UNKNOWN:}
\DoxyCodeLine{1060                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 3)}
\DoxyCodeLine{1061             case TokenBaseType.F15\_SLASH:}
\DoxyCodeLine{1062                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 16)}
\DoxyCodeLine{1063             case TokenBaseType.F15\_SPEED\_VFR:}
\DoxyCodeLine{1064                 self.assign\_speed\_vfr(ers, tokens, next\_token)}
\DoxyCodeLine{1065             case TokenBaseType.F15\_SPEED\_ALTITUDE:}
\DoxyCodeLine{1066                 self.assign\_speed\_altitude(ers, tokens, next\_token)}
\DoxyCodeLine{1067             case TokenBaseType.F15\_TOO\_LONG:}
\DoxyCodeLine{1068                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 4)}
\DoxyCodeLine{1069             case \_:}
\DoxyCodeLine{1070                 \textcolor{comment}{\# TokenBaseType.F15\_BREAK\_START | TokenBaseType.F15\_BREAK\_END |}}
\DoxyCodeLine{1071                 \textcolor{comment}{\# TokenBaseType.F15\_DCT | TokenBaseType.F15\_STAY |}}
\DoxyCodeLine{1072                 \textcolor{comment}{\# TokenBaseType.F15\_TRUNCATE | TokenBaseType.F15\_C |}}
\DoxyCodeLine{1073                 \textcolor{comment}{\# TokenBaseType.F15\_POINT | TokenBaseType.F15\_ROUTE |}}
\DoxyCodeLine{1074                 \textcolor{comment}{\# TokenBaseType.F15\_SID\_STAR | TokenBaseType.F15\_SPEED\_ALTITUDE\_ALTITUDE |}}
\DoxyCodeLine{1075                 \textcolor{comment}{\# TokenBaseType.F15\_SPEED\_ALTITUDE\_PLUS | TokenBaseType.F15\_STAY\_TIME |}}
\DoxyCodeLine{1076                 \textcolor{comment}{\# TokenBaseType.F15\_SID | TokenBaseType.F15\_STAR}}
\DoxyCodeLine{1077                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 50)}
\DoxyCodeLine{1078 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a9c0ccde701beda868b808f19123b95c8}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a9c0ccde701beda868b808f19123b95c8}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!parse\_f15@{parse\_f15}}
\index{parse\_f15@{parse\_f15}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{parse\_f15()}{parse\_f15()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+parse\+\_\+f15 (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens }\end{DoxyParamCaption})}

\begin{DoxyVerb}Entry point for the field 15 parser. Field 15 must start with one of two
element types, either SPEED/ALTITUDE or SPEED/VFR, everything else is an error.
When the ExtractedRouteRecord class is instantiated, record 0 is automatically created
that represents the ADEP.

The flight rules are set on the ADEP record based on the first field 15 token, either:
    - 'IFR' for SPEED/ALTITUDE or
    - 'VFR' for SPEED/VFR.
Once parsing is complete an ADES record is added representing the ADES.

It is the callers responsibility to populate the ADEP and ADES with pertinent
information once parsing is complete.

The records in an instance of ExtractedRouteSequence class contains a complete extracted
route with all points, routes, flight rules, speed and altitudes etc. along a route.

:param ers: An instance of ExtractedRouteSequence class being populated by the parser;
:param tokens: A list of tokens extracted from field 15 used as input to the parser.
       This structure contains a tokenized form of all field 15 tokens used as
       input to this parser.
:return: True if no errors were detected, False otherwise. If False is returned a
 caller can recover a complete list of all erroneous tokens by calling
 ExtractedRouteRecord.get_errors();
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{52     \textcolor{keyword}{def }parse\_f15(self, ers, tokens):}
\DoxyCodeLine{53         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens) -\/> bool}}
\DoxyCodeLine{54         \textcolor{stringliteral}{"""Entry point for the field 15 parser. Field 15 must start with one of two}}
\DoxyCodeLine{55 \textcolor{stringliteral}{        element types, either SPEED/ALTITUDE or SPEED/VFR, everything else is an error.}}
\DoxyCodeLine{56 \textcolor{stringliteral}{        When the ExtractedRouteRecord class is instantiated, record 0 is automatically created}}
\DoxyCodeLine{57 \textcolor{stringliteral}{        that represents the ADEP.}}
\DoxyCodeLine{58 \textcolor{stringliteral}{}}
\DoxyCodeLine{59 \textcolor{stringliteral}{        The flight rules are set on the ADEP record based on the first field 15 token, either:}}
\DoxyCodeLine{60 \textcolor{stringliteral}{            -\/ 'IFR' for SPEED/ALTITUDE or}}
\DoxyCodeLine{61 \textcolor{stringliteral}{            -\/ 'VFR' for SPEED/VFR.}}
\DoxyCodeLine{62 \textcolor{stringliteral}{        Once parsing is complete an ADES record is added representing the ADES.}}
\DoxyCodeLine{63 \textcolor{stringliteral}{}}
\DoxyCodeLine{64 \textcolor{stringliteral}{        It is the callers responsibility to populate the ADEP and ADES with pertinent}}
\DoxyCodeLine{65 \textcolor{stringliteral}{        information once parsing is complete.}}
\DoxyCodeLine{66 \textcolor{stringliteral}{}}
\DoxyCodeLine{67 \textcolor{stringliteral}{        The records in an instance of ExtractedRouteSequence class contains a complete extracted}}
\DoxyCodeLine{68 \textcolor{stringliteral}{        route with all points, routes, flight rules, speed and altitudes etc. along a route.}}
\DoxyCodeLine{69 \textcolor{stringliteral}{}}
\DoxyCodeLine{70 \textcolor{stringliteral}{        :param ers: An instance of ExtractedRouteSequence class being populated by the parser;}}
\DoxyCodeLine{71 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser.}}
\DoxyCodeLine{72 \textcolor{stringliteral}{               This structure contains a tokenized form of all field 15 tokens used as}}
\DoxyCodeLine{73 \textcolor{stringliteral}{               input to this parser.}}
\DoxyCodeLine{74 \textcolor{stringliteral}{        :return: True if no errors were detected, False otherwise. If False is returned a}}
\DoxyCodeLine{75 \textcolor{stringliteral}{                 caller can recover a complete list of all erroneous tokens by calling}}
\DoxyCodeLine{76 \textcolor{stringliteral}{                 ExtractedRouteRecord.get\_errors();}}
\DoxyCodeLine{77 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{78         \textcolor{comment}{\# Loop over all the tokens and assign a tokens base and subtype; this identifies a token and is used}}
\DoxyCodeLine{79         \textcolor{comment}{\# by the parser to ensure correct grammar and semantics.}}
\DoxyCodeLine{80         self.assign\_syntax\_descriptions(tokens)}
\DoxyCodeLine{81 }
\DoxyCodeLine{82         \textcolor{comment}{\# Get the first field 15 token}}
\DoxyCodeLine{83         token = tokens.get\_first\_token()}
\DoxyCodeLine{84         \textcolor{keywordflow}{if} token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{85             \textcolor{comment}{\# Add a dummy error record and report an error}}
\DoxyCodeLine{86             ers.add\_error(\textcolor{stringliteral}{"NULL"}, 0, 0, TokenBaseType.F15\_UNKNOWN,}
\DoxyCodeLine{87                           TokenSubType.F15\_SB\_UNKNOWN, ErrorMessages.error\_messages[41])}
\DoxyCodeLine{88             \textcolor{comment}{\# Add a dummy ADES}}
\DoxyCodeLine{89             ers.add\_dummy\_ades()}
\DoxyCodeLine{90             \textcolor{keywordflow}{return} \textcolor{keyword}{False}}
\DoxyCodeLine{91         base\_type = token.get\_token\_base\_type()}
\DoxyCodeLine{92         match base\_type:}
\DoxyCodeLine{93             case TokenBaseType.F15\_SPEED\_VFR:}
\DoxyCodeLine{94                 self.assign\_speed\_vfr(ers, tokens, token)}
\DoxyCodeLine{95                 ers.get\_first\_element().set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"V"}])}
\DoxyCodeLine{96             case TokenBaseType.F15\_SPEED\_ALTITUDE:}
\DoxyCodeLine{97                 self.assign\_speed\_altitude(ers, tokens, token)}
\DoxyCodeLine{98                 \textcolor{keywordflow}{if} tokens.get\_number\_of\_tokens() == 1:}
\DoxyCodeLine{99                     \textcolor{comment}{\# Only one token means field 15 has no further route description}}
\DoxyCodeLine{100                     self.add\_error\_and\_re\_sync(ers, tokens, token, 49)}
\DoxyCodeLine{101             case \_:}
\DoxyCodeLine{102                 \textcolor{comment}{\# Error, field 15 must start with a 'Speed/altitude' or 'Speed VFR' token}}
\DoxyCodeLine{103                 self.add\_error\_and\_re\_sync(ers, tokens, token, 1)}
\DoxyCodeLine{104 }
\DoxyCodeLine{105         \textcolor{comment}{\# Add a dummy ADES}}
\DoxyCodeLine{106         ades = ers.add\_dummy\_ades()}
\DoxyCodeLine{107         \textcolor{comment}{\# Get the rules from the last but one ERS record and assign it to the ADES}}
\DoxyCodeLine{108         previous = ers.get\_previous\_to\_last\_element()}
\DoxyCodeLine{109         \textcolor{keywordflow}{if} previous \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{110             \textcolor{keywordflow}{return} ers.get\_number\_of\_errors() == 0}
\DoxyCodeLine{111         ades.set\_flight\_rules(previous.get\_flight\_rules())}
\DoxyCodeLine{112 }
\DoxyCodeLine{113         \textcolor{comment}{\# Figure out the flight rules from the extracted route}}
\DoxyCodeLine{114         \textcolor{keywordflow}{if} ers.get\_first\_element().get\_flight\_rules() == \textcolor{stringliteral}{"VFR"}:}
\DoxyCodeLine{115             ers.set\_derived\_flight\_rules(\textcolor{stringliteral}{"V"})}
\DoxyCodeLine{116             \textcolor{keywordflow}{for} ers\_record \textcolor{keywordflow}{in} ers.get\_all\_elements():}
\DoxyCodeLine{117                 \textcolor{keywordflow}{if} ers\_record.get\_flight\_rules() == \textcolor{stringliteral}{"IFR"}:}
\DoxyCodeLine{118                     ers.set\_derived\_flight\_rules(\textcolor{stringliteral}{"Z"})}
\DoxyCodeLine{119                     \textcolor{keywordflow}{break}}
\DoxyCodeLine{120         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{121             ers.set\_derived\_flight\_rules(\textcolor{stringliteral}{"I"})}
\DoxyCodeLine{122             \textcolor{keywordflow}{for} ers\_record \textcolor{keywordflow}{in} ers.get\_all\_elements():}
\DoxyCodeLine{123                 \textcolor{keywordflow}{if} ers\_record.get\_flight\_rules() == \textcolor{stringliteral}{"VFR"}:}
\DoxyCodeLine{124                     ers.set\_derived\_flight\_rules(\textcolor{stringliteral}{"Y"})}
\DoxyCodeLine{125                     \textcolor{keywordflow}{break}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127         \textcolor{comment}{\# Return True if no errors have been reported}}
\DoxyCodeLine{128         \textcolor{keywordflow}{return} ers.get\_number\_of\_errors() == 0}
\DoxyCodeLine{129 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_ab56178e8f6f1091b58bc872020bf4d3e}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_ab56178e8f6f1091b58bc872020bf4d3e}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!point@{point}}
\index{point@{point}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{point()}{point()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+point (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes a point element. Points are always IFR elements, hence the rules are always
set to IFR on point elements and stored in the ERS. The angle semantics for Latitude / Longitude and
bearing distance points are checked with appropriate errors reported if semantic errors exist.

:param ers: An ExtractedRouteSequence class instance containing an IFR element record in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: A point token being appended to the ERS;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1217     \textcolor{keyword}{def }point(self, ers, tokens, token):}
\DoxyCodeLine{1218         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{1219         \textcolor{stringliteral}{"""This method processes a point element. Points are always IFR elements, hence the rules are always}}
\DoxyCodeLine{1220 \textcolor{stringliteral}{        set to IFR on point elements and stored in the ERS. The angle semantics for Latitude / Longitude and}}
\DoxyCodeLine{1221 \textcolor{stringliteral}{        bearing distance points are checked with appropriate errors reported if semantic errors exist.}}
\DoxyCodeLine{1222 \textcolor{stringliteral}{}}
\DoxyCodeLine{1223 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing an IFR element record in the last ERS record.}}
\DoxyCodeLine{1224 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1225 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1226 \textcolor{stringliteral}{        :param token: A point token being appended to the ERS;}}
\DoxyCodeLine{1227 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1228 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1229         self.add\_record(ers, token)}
\DoxyCodeLine{1230         ers.get\_last\_element().set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"I"}])}
\DoxyCodeLine{1231 }
\DoxyCodeLine{1232         \textcolor{comment}{\# Check lat/long and bearing distance semantics}}
\DoxyCodeLine{1233         \textcolor{keywordflow}{if} token.get\_token\_sub\_type() != TokenSubType.F15\_SB\_PRP \textcolor{keywordflow}{and} \(\backslash\)}
\DoxyCodeLine{1234                 token.get\_token\_sub\_type() != TokenSubType.F15\_SB\_PRP\_AERO:}
\DoxyCodeLine{1235             self.assign\_lat\_long\_bearing\_distance(ers, token)}
\DoxyCodeLine{1236 }
\DoxyCodeLine{1237         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{1238         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1239             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1240 }
\DoxyCodeLine{1241         self.post\_point(ers, tokens, next\_token)}
\DoxyCodeLine{1242 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_add6607a7f5f3c3a6632c72f135753b7a}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_add6607a7f5f3c3a6632c72f135753b7a}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!post\_adep@{post\_adep}}
\index{post\_adep@{post\_adep}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{post\_adep()}{post\_adep()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+post\+\_\+adep (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method determines the next node to move to after a speed/altitude has been applied to the
first ERS record, the ADEP element.

:param ers: An ExtractedRouteSequence class instance containing only the ADEP record element
       in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: The first token in the tokens list.
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1079     \textcolor{keyword}{def }post\_adep(self, ers, tokens, token):}
\DoxyCodeLine{1080         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{1081         \textcolor{stringliteral}{"""This method determines the next node to move to after a speed/altitude has been applied to the}}
\DoxyCodeLine{1082 \textcolor{stringliteral}{        first ERS record, the ADEP element.}}
\DoxyCodeLine{1083 \textcolor{stringliteral}{}}
\DoxyCodeLine{1084 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing only the ADEP record element}}
\DoxyCodeLine{1085 \textcolor{stringliteral}{               in the last ERS record.}}
\DoxyCodeLine{1086 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1087 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1088 \textcolor{stringliteral}{        :param token: The first token in the tokens list.}}
\DoxyCodeLine{1089 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1090 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1091         base\_type = token.get\_token\_base\_type()}
\DoxyCodeLine{1092         match base\_type:}
\DoxyCodeLine{1093             case TokenBaseType.F15\_UNKNOWN:}
\DoxyCodeLine{1094                 self.add\_error\_and\_re\_sync(ers, tokens, token, 3)}
\DoxyCodeLine{1095             case TokenBaseType.F15\_SLASH | TokenBaseType.F15\_BREAK\_START | \(\backslash\)}
\DoxyCodeLine{1096                     TokenBaseType.F15\_SPEED\_VFR | TokenBaseType.F15\_SPEED\_ALTITUDE | \(\backslash\)}
\DoxyCodeLine{1097                     TokenBaseType.F15\_BREAK\_END | TokenBaseType.F15\_STAY | \(\backslash\)}
\DoxyCodeLine{1098                     TokenBaseType.F15\_C:}
\DoxyCodeLine{1099                 self.add\_error\_and\_re\_sync(ers, tokens, token, 23)}
\DoxyCodeLine{1100             case TokenBaseType.F15\_DCT:}
\DoxyCodeLine{1101                 self.dct(ers, tokens, token)}
\DoxyCodeLine{1102             case TokenBaseType.F15\_TRUNCATE:}
\DoxyCodeLine{1103                 self.truncate(ers, tokens)}
\DoxyCodeLine{1104             case TokenBaseType.F15\_POINT:}
\DoxyCodeLine{1105                 self.point(ers, tokens, token)}
\DoxyCodeLine{1106             case TokenBaseType.F15\_ROUTE:}
\DoxyCodeLine{1107                 self.add\_error\_and\_re\_sync(ers, tokens, token, 24)}
\DoxyCodeLine{1108             case TokenBaseType.F15\_SID\_STAR:}
\DoxyCodeLine{1109                 self.sid\_star(ers, tokens, token)}
\DoxyCodeLine{1110             case TokenBaseType.F15\_SPEED\_ALTITUDE\_ALTITUDE | TokenBaseType.F15\_SPEED\_ALTITUDE\_PLUS:}
\DoxyCodeLine{1111                 self.add\_error\_and\_re\_sync(ers, tokens, token, 9)}
\DoxyCodeLine{1112             case TokenBaseType.F15\_TOO\_LONG:}
\DoxyCodeLine{1113                 self.add\_error\_and\_re\_sync(ers, tokens, token, 4)}
\DoxyCodeLine{1114             case TokenBaseType.F15\_STAY\_TIME:}
\DoxyCodeLine{1115                 self.add\_error\_and\_re\_sync(ers, tokens, token, 10)}
\DoxyCodeLine{1116             case TokenBaseType.F15\_SID:}
\DoxyCodeLine{1117                 self.sid(ers, tokens, token)}
\DoxyCodeLine{1118             case TokenBaseType.F15\_STAR:}
\DoxyCodeLine{1119                 self.star(ers, tokens, token)}
\DoxyCodeLine{1120             case \_:}
\DoxyCodeLine{1121                 self.add\_error\_and\_re\_sync(ers, tokens, token, 0)}
\DoxyCodeLine{1122 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a3d17c6d784e9b84170991265d95b07a6}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a3d17c6d784e9b84170991265d95b07a6}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!post\_point@{post\_point}}
\index{post\_point@{post\_point}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{post\_point()}{post\_point()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+post\+\_\+point (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method determines the next node to move to following a point element.

:param ers: An ExtractedRouteSequence class instance containing an IFR element record in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: A token being checked if it can follow an IFR point;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1123     \textcolor{keyword}{def }post\_point(self, ers, tokens, token):}
\DoxyCodeLine{1124         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{1125         \textcolor{stringliteral}{"""This method determines the next node to move to following a point element.}}
\DoxyCodeLine{1126 \textcolor{stringliteral}{}}
\DoxyCodeLine{1127 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing an IFR element record in the last ERS record.}}
\DoxyCodeLine{1128 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1129 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1130 \textcolor{stringliteral}{        :param token: A token being checked if it can follow an IFR point;}}
\DoxyCodeLine{1131 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1132 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1133         base\_type = token.get\_token\_base\_type()}
\DoxyCodeLine{1134         match base\_type:}
\DoxyCodeLine{1135             case TokenBaseType.F15\_UNKNOWN:}
\DoxyCodeLine{1136                 self.add\_error\_and\_re\_sync(ers, tokens, token, 3)}
\DoxyCodeLine{1137             case TokenBaseType.F15\_SLASH:}
\DoxyCodeLine{1138                 self.forward\_slash(ers, tokens, token)}
\DoxyCodeLine{1139             case TokenBaseType.F15\_BREAK\_START:}
\DoxyCodeLine{1140                 self.break\_start(ers, tokens, token)}
\DoxyCodeLine{1141             case TokenBaseType.F15\_SPEED\_VFR | TokenBaseType.F15\_SPEED\_ALTITUDE:}
\DoxyCodeLine{1142                 self.add\_error\_and\_re\_sync(ers, tokens, token, 5)}
\DoxyCodeLine{1143             case TokenBaseType.F15\_BREAK\_END:}
\DoxyCodeLine{1144                 self.break\_end\_error(ers, tokens, token)}
\DoxyCodeLine{1145             case TokenBaseType.F15\_DCT:}
\DoxyCodeLine{1146                 self.dct(ers, tokens, token)}
\DoxyCodeLine{1147             case TokenBaseType.F15\_STAY:}
\DoxyCodeLine{1148                 self.stay(ers, tokens, token)}
\DoxyCodeLine{1149             case TokenBaseType.F15\_TRUNCATE:}
\DoxyCodeLine{1150                 self.truncate(ers, tokens)}
\DoxyCodeLine{1151             case TokenBaseType.F15\_C:}
\DoxyCodeLine{1152                 self.cruise\_climb\_c(ers, tokens, token)}
\DoxyCodeLine{1153             case TokenBaseType.F15\_POINT:}
\DoxyCodeLine{1154                 self.point(ers, tokens, token)}
\DoxyCodeLine{1155             case TokenBaseType.F15\_ROUTE:}
\DoxyCodeLine{1156                 last\_ers\_rec = ers.get\_last\_element()}
\DoxyCodeLine{1157                 sub\_type = last\_ers\_rec.get\_sub\_type()}
\DoxyCodeLine{1158                 \textcolor{keywordflow}{if} sub\_type == TokenSubType.F15\_SB\_PRP\_BD \textcolor{keywordflow}{or} sub\_type == TokenSubType.F15\_SB\_LL\_DEG \textcolor{keywordflow}{or} \(\backslash\)}
\DoxyCodeLine{1159                    sub\_type == TokenSubType.F15\_SB\_LL\_MIN \textcolor{keywordflow}{or} sub\_type == TokenSubType.F15\_SB\_LLBD\_DEG \textcolor{keywordflow}{or} \(\backslash\)}
\DoxyCodeLine{1160                    sub\_type == TokenSubType.F15\_SB\_LLBD\_MIN:}
\DoxyCodeLine{1161                     self.add\_error\_and\_re\_sync(ers, tokens, token, 47)}
\DoxyCodeLine{1162                 \textcolor{keywordflow}{else}:}
\DoxyCodeLine{1163                     self.route(ers, tokens, token)}
\DoxyCodeLine{1164             case TokenBaseType.F15\_SID\_STAR:}
\DoxyCodeLine{1165                 self.sid\_star(ers, tokens, token)}
\DoxyCodeLine{1166             case TokenBaseType.F15\_SPEED\_ALTITUDE\_ALTITUDE | TokenBaseType.F15\_SPEED\_ALTITUDE\_PLUS:}
\DoxyCodeLine{1167                 self.add\_error\_and\_re\_sync(ers, tokens, token, 9)}
\DoxyCodeLine{1168             case TokenBaseType.F15\_TOO\_LONG:}
\DoxyCodeLine{1169                 self.add\_error\_and\_re\_sync(ers, tokens, token, 4)}
\DoxyCodeLine{1170             case TokenBaseType.F15\_STAY\_TIME:}
\DoxyCodeLine{1171                 self.add\_error\_and\_re\_sync(ers, tokens, token, 10)}
\DoxyCodeLine{1172             case TokenBaseType.F15\_SID:}
\DoxyCodeLine{1173                 self.sid(ers, tokens, token)}
\DoxyCodeLine{1174             case TokenBaseType.F15\_STAR:}
\DoxyCodeLine{1175                 self.star(ers, tokens, token)}
\DoxyCodeLine{1176             case \_:}
\DoxyCodeLine{1177                 self.add\_error\_and\_re\_sync(ers, tokens, token, 0)}
\DoxyCodeLine{1178 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a5ebff4c126937669f5408cfdf66b6510}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a5ebff4c126937669f5408cfdf66b6510}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!post\_sid@{post\_sid}}
\index{post\_sid@{post\_sid}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{post\_sid()}{post\_sid()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+post\+\_\+sid (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method determines the next node to move to following an SID element.

:param ers: An ExtractedRouteSequence class instance containing an SID element record in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure contains
       a tokenized form of all field 15 tokens used as input to this parser.
:return: A token being checked if it can follow an SID element;
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1179     \textcolor{keyword}{def }post\_sid(self, ers, tokens):}
\DoxyCodeLine{1180         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens) -\/> None}}
\DoxyCodeLine{1181         \textcolor{stringliteral}{"""This method determines the next node to move to following an SID element.}}
\DoxyCodeLine{1182 \textcolor{stringliteral}{}}
\DoxyCodeLine{1183 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing an SID element record in the last ERS record.}}
\DoxyCodeLine{1184 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure contains}}
\DoxyCodeLine{1185 \textcolor{stringliteral}{               a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1186 \textcolor{stringliteral}{        :return: A token being checked if it can follow an SID element;}}
\DoxyCodeLine{1187 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1188         \textcolor{comment}{\# Get the next token and determine the next node}}
\DoxyCodeLine{1189         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{1190         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1191             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1192         base\_type = next\_token.get\_token\_base\_type()}
\DoxyCodeLine{1193         match base\_type:}
\DoxyCodeLine{1194             case TokenBaseType.F15\_TRUNCATE:}
\DoxyCodeLine{1195                 self.truncate(ers, tokens)}
\DoxyCodeLine{1196             case TokenBaseType.F15\_POINT:}
\DoxyCodeLine{1197                 self.point(ers, tokens, next\_token)}
\DoxyCodeLine{1198             case TokenBaseType.F15\_ROUTE:}
\DoxyCodeLine{1199                 self.route(ers, tokens, next\_token)}
\DoxyCodeLine{1200             case TokenBaseType.F15\_SID\_STAR:}
\DoxyCodeLine{1201                 self.sid\_star(ers, tokens, next\_token)}
\DoxyCodeLine{1202             case TokenBaseType.F15\_TOO\_LONG:}
\DoxyCodeLine{1203                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 4)}
\DoxyCodeLine{1204             case TokenBaseType.F15\_SID:}
\DoxyCodeLine{1205                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 32)}
\DoxyCodeLine{1206             case TokenBaseType.F15\_STAR:}
\DoxyCodeLine{1207                 self.star(ers, tokens, next\_token)}
\DoxyCodeLine{1208             case \_:}
\DoxyCodeLine{1209                 \textcolor{comment}{\# TokenBaseType.F15\_UNKNOWN | TokenBaseType.F15\_SLASH |}}
\DoxyCodeLine{1210                 \textcolor{comment}{\# TokenBaseType.F15\_BREAK\_START | TokenBaseType.F15\_SPEED\_VFR |}}
\DoxyCodeLine{1211                 \textcolor{comment}{\# TokenBaseType.F15\_SPEED\_ALTITUDE | TokenBaseType.F15\_BREAK\_END |}}
\DoxyCodeLine{1212                 \textcolor{comment}{\# TokenBaseType.F15\_DCT | TokenBaseType.F15\_STAY |}}
\DoxyCodeLine{1213                 \textcolor{comment}{\# TokenBaseType.F15\_C | TokenBaseType.F15\_SPEED\_ALTITUDE\_ALTITUDE |}}
\DoxyCodeLine{1214                 \textcolor{comment}{\# TokenBaseType.F15\_SPEED\_ALTITUDE\_PLUS | TokenBaseType.F15\_STAY\_TIME:}}
\DoxyCodeLine{1215                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 31)}
\DoxyCodeLine{1216 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_ad676a053a6889ef209578acdc363fd6f}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_ad676a053a6889ef209578acdc363fd6f}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!re\_sync\_parser\_after\_error@{re\_sync\_parser\_after\_error}}
\index{re\_sync\_parser\_after\_error@{re\_sync\_parser\_after\_error}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{re\_sync\_parser\_after\_error()}{re\_sync\_parser\_after\_error()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+re\+\_\+sync\+\_\+parser\+\_\+after\+\_\+error (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method attempts to re-synchronize the parser after an error is reported. This method is called
whenever an error is reported / added by the 'self.add_error()' method. The next token is retrieved
and based on its type, after which parsing continues based on the next tokens element type.

:param ers: An ExtractedRouteSequence class instance containing an erroneous element record in
       the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1261     \textcolor{keyword}{def }re\_sync\_parser\_after\_error(self, ers, tokens):}
\DoxyCodeLine{1262         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens) -\/> None}}
\DoxyCodeLine{1263         \textcolor{stringliteral}{"""This method attempts to re-\/synchronize the parser after an error is reported. This method is called}}
\DoxyCodeLine{1264 \textcolor{stringliteral}{        whenever an error is reported / added by the 'self.add\_error()' method. The next token is retrieved}}
\DoxyCodeLine{1265 \textcolor{stringliteral}{        and based on its type, after which parsing continues based on the next tokens element type.}}
\DoxyCodeLine{1266 \textcolor{stringliteral}{}}
\DoxyCodeLine{1267 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing an erroneous element record in}}
\DoxyCodeLine{1268 \textcolor{stringliteral}{               the last ERS record.}}
\DoxyCodeLine{1269 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1270 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1271 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1272 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1273         token = tokens.get\_next\_token()}
\DoxyCodeLine{1274         \textcolor{keywordflow}{if} token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1275             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1276         base\_type = token.get\_token\_base\_type()}
\DoxyCodeLine{1277         match base\_type:}
\DoxyCodeLine{1278             case TokenBaseType.F15\_UNKNOWN:}
\DoxyCodeLine{1279                 self.add\_error\_and\_re\_sync(ers, tokens, token, 3)}
\DoxyCodeLine{1280             case TokenBaseType.F15\_SLASH:}
\DoxyCodeLine{1281                 \textcolor{comment}{\# Skip the '/' token, only interested in what follows}}
\DoxyCodeLine{1282                 next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{1283                 \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1284                     \textcolor{comment}{\# Field 15 cannot end with a '/'}}
\DoxyCodeLine{1285                     self.add\_error\_and\_re\_sync(ers, tokens, token, 25)}
\DoxyCodeLine{1286                     \textcolor{keywordflow}{return}}
\DoxyCodeLine{1287                 next\_base\_type = next\_token.get\_token\_base\_type()}
\DoxyCodeLine{1288                 match next\_base\_type:}
\DoxyCodeLine{1289                     case TokenBaseType.F15\_SPEED\_VFR:}
\DoxyCodeLine{1290                         self.assign\_speed\_vfr(ers, tokens, next\_token)}
\DoxyCodeLine{1291                     case TokenBaseType.F15\_POINT:}
\DoxyCodeLine{1292                         self.point(ers, tokens, next\_token)}
\DoxyCodeLine{1293                     case TokenBaseType.F15\_SPEED\_ALTITUDE:}
\DoxyCodeLine{1294                         self.assign\_speed\_altitude(ers, tokens, next\_token)}
\DoxyCodeLine{1295                     case TokenBaseType.F15\_SPEED\_ALTITUDE\_ALTITUDE:}
\DoxyCodeLine{1296                         self.assign\_speed\_altitude\_altitude(ers, tokens, next\_token)}
\DoxyCodeLine{1297                     case TokenBaseType.F15\_SPEED\_ALTITUDE\_PLUS:}
\DoxyCodeLine{1298                         self.assign\_speed\_altitude\_plus(ers, tokens, next\_token)}
\DoxyCodeLine{1299                     case \_:}
\DoxyCodeLine{1300                         self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 11)}
\DoxyCodeLine{1301             case TokenBaseType.F15\_BREAK\_START:}
\DoxyCodeLine{1302                 self.break\_start(ers, tokens, token)}
\DoxyCodeLine{1303             case TokenBaseType.F15\_SPEED\_VFR:}
\DoxyCodeLine{1304                 self.assign\_speed\_vfr(ers, tokens, token)}
\DoxyCodeLine{1305             case TokenBaseType.F15\_BREAK\_END:}
\DoxyCodeLine{1306                 self.break\_end(ers, tokens, token)}
\DoxyCodeLine{1307             case TokenBaseType.F15\_DCT:}
\DoxyCodeLine{1308                 self.dct(ers, tokens, token)}
\DoxyCodeLine{1309             case TokenBaseType.F15\_STAY:}
\DoxyCodeLine{1310                 self.stay(ers, tokens, token)}
\DoxyCodeLine{1311             case TokenBaseType.F15\_TRUNCATE:}
\DoxyCodeLine{1312                 self.truncate(ers, tokens)}
\DoxyCodeLine{1313             case TokenBaseType.F15\_C:}
\DoxyCodeLine{1314                 self.cruise\_climb\_c(ers, tokens, token)}
\DoxyCodeLine{1315             case TokenBaseType.F15\_POINT:}
\DoxyCodeLine{1316                 self.point(ers, tokens, token)}
\DoxyCodeLine{1317             case TokenBaseType.F15\_ROUTE:}
\DoxyCodeLine{1318                 self.route(ers, tokens, token)}
\DoxyCodeLine{1319             case TokenBaseType.F15\_SID\_STAR:}
\DoxyCodeLine{1320                 self.sid\_star(ers, tokens, token)}
\DoxyCodeLine{1321             case TokenBaseType.F15\_SPEED\_ALTITUDE:}
\DoxyCodeLine{1322                 self.assign\_speed\_altitude(ers, tokens, token)}
\DoxyCodeLine{1323             case TokenBaseType.F15\_SPEED\_ALTITUDE\_ALTITUDE:}
\DoxyCodeLine{1324                 self.assign\_speed\_altitude\_altitude(ers, tokens, token)}
\DoxyCodeLine{1325             case TokenBaseType.F15\_SPEED\_ALTITUDE\_PLUS:}
\DoxyCodeLine{1326                 self.assign\_speed\_altitude\_plus(ers, tokens, token)}
\DoxyCodeLine{1327             case TokenBaseType.F15\_TOO\_LONG:}
\DoxyCodeLine{1328                 self.add\_error\_and\_re\_sync(ers, tokens, token, 4)}
\DoxyCodeLine{1329             case TokenBaseType.F15\_STAY\_TIME:}
\DoxyCodeLine{1330                 self.add\_error\_and\_re\_sync(ers, tokens, token, 10)}
\DoxyCodeLine{1331             case TokenBaseType.F15\_SID:}
\DoxyCodeLine{1332                 self.sid(ers, tokens, token)}
\DoxyCodeLine{1333             case TokenBaseType.F15\_STAR:}
\DoxyCodeLine{1334                 self.star(ers, tokens, token)}
\DoxyCodeLine{1335             case \_:}
\DoxyCodeLine{1336                 \textcolor{comment}{\# In theory this should never happen}}
\DoxyCodeLine{1337                 self.add\_error\_and\_re\_sync(ers, tokens, token, 0)}
\DoxyCodeLine{1338 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a9476aa7ec48bcff3c24cb36de0c4ca2e}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a9476aa7ec48bcff3c24cb36de0c4ca2e}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!resolve\_real\_bd\_point@{resolve\_real\_bd\_point}}
\index{resolve\_real\_bd\_point@{resolve\_real\_bd\_point}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{resolve\_real\_bd\_point()}{resolve\_real\_bd\_point()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+resolve\+\_\+real\+\_\+bd\+\_\+point (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{ex\+\_\+route\+\_\+rec,  }\item[{}]{bearing,  }\item[{}]{distance }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method calculates the coordinates for a point given by a Lat / Long / Bearing / Distance

:param ers: The complete extracted route sequence;
:param ex_route_rec: The extracted route record containing the lat/long of the point to which the
       bearing / distance relate.
:param bearing: The bearing from the point along which the point to be calculated lies.
:param distance: The distance along the bearing where the point lies;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1243     \textcolor{keyword}{def }resolve\_real\_bd\_point(self, ers, ex\_route\_rec, bearing, distance):}
\DoxyCodeLine{1244         \textcolor{comment}{\# type: (ExtractedRouteSequence, ExtractedRouteRecord, float, float) -\/> None}}
\DoxyCodeLine{1245         \textcolor{stringliteral}{"""This method calculates the coordinates for a point given by a Lat / Long / Bearing / Distance}}
\DoxyCodeLine{1246 \textcolor{stringliteral}{}}
\DoxyCodeLine{1247 \textcolor{stringliteral}{        :param ers: The complete extracted route sequence;}}
\DoxyCodeLine{1248 \textcolor{stringliteral}{        :param ex\_route\_rec: The extracted route record containing the lat/long of the point to which the}}
\DoxyCodeLine{1249 \textcolor{stringliteral}{               bearing / distance relate.}}
\DoxyCodeLine{1250 \textcolor{stringliteral}{        :param bearing: The bearing from the point along which the point to be calculated lies.}}
\DoxyCodeLine{1251 \textcolor{stringliteral}{        :param distance: The distance along the bearing where the point lies;}}
\DoxyCodeLine{1252 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1253 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1254         result = Utils().get\_bearing\_distance\_projected\_point(}
\DoxyCodeLine{1255             ex\_route\_rec.get\_latitude(), ex\_route\_rec.get\_longitude(),}
\DoxyCodeLine{1256             bearing, distance * Constants.NM\_TO\_METERS)}
\DoxyCodeLine{1257         ex\_route\_rec.set\_latitude(result[0])}
\DoxyCodeLine{1258         ex\_route\_rec.set\_longitude(result[1])}
\DoxyCodeLine{1259         self.assign\_azimuth\_distance\_between\_points(ers)}
\DoxyCodeLine{1260 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_aa54a727a8f93fd8858c3989c98afe0e5}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_aa54a727a8f93fd8858c3989c98afe0e5}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!route@{route}}
\index{route@{route}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{route()}{route()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+route (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes an ATS route element. Routes are always IFR elements, hence the rules are
always set to IFR on route elements and stored in the ERS.

:param ers: An ExtractedRouteSequence class instance containing an IFR element record in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: An ATS route token being appended to the ERS;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1339     \textcolor{keyword}{def }route(self, ers, tokens, token):}
\DoxyCodeLine{1340         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{1341         \textcolor{stringliteral}{"""This method processes an ATS route element. Routes are always IFR elements, hence the rules are}}
\DoxyCodeLine{1342 \textcolor{stringliteral}{        always set to IFR on route elements and stored in the ERS.}}
\DoxyCodeLine{1343 \textcolor{stringliteral}{}}
\DoxyCodeLine{1344 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing an IFR element record in the last ERS record.}}
\DoxyCodeLine{1345 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1346 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1347 \textcolor{stringliteral}{        :param token: An ATS route token being appended to the ERS;}}
\DoxyCodeLine{1348 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1349 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1350         self.add\_record(ers, token)}
\DoxyCodeLine{1351         ers.get\_last\_element().set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"I"}])}
\DoxyCodeLine{1352         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{1353         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1354             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1355         base\_type = next\_token.get\_token\_base\_type()}
\DoxyCodeLine{1356         match base\_type:}
\DoxyCodeLine{1357             case TokenBaseType.F15\_UNKNOWN:}
\DoxyCodeLine{1358                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 3)}
\DoxyCodeLine{1359             case TokenBaseType.F15\_SLASH:}
\DoxyCodeLine{1360                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 12)}
\DoxyCodeLine{1361             case TokenBaseType.F15\_BREAK\_START:}
\DoxyCodeLine{1362                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 13)}
\DoxyCodeLine{1363             case TokenBaseType.F15\_SPEED\_VFR:}
\DoxyCodeLine{1364                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 13)}
\DoxyCodeLine{1365             case TokenBaseType.F15\_SPEED\_ALTITUDE:}
\DoxyCodeLine{1366                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 55)}
\DoxyCodeLine{1367             case TokenBaseType.F15\_BREAK\_END:}
\DoxyCodeLine{1368                 self.break\_end\_error(ers, tokens, next\_token)}
\DoxyCodeLine{1369             case TokenBaseType.F15\_DCT:}
\DoxyCodeLine{1370                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 14)}
\DoxyCodeLine{1371             case TokenBaseType.F15\_STAY:}
\DoxyCodeLine{1372                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 15)}
\DoxyCodeLine{1373             case TokenBaseType.F15\_TRUNCATE:}
\DoxyCodeLine{1374                 self.truncate(ers, tokens)}
\DoxyCodeLine{1375             case TokenBaseType.F15\_C:}
\DoxyCodeLine{1376                 self.cruise\_climb\_c(ers, tokens, next\_token)}
\DoxyCodeLine{1377             case TokenBaseType.F15\_POINT:}
\DoxyCodeLine{1378                 \textcolor{comment}{\# A Lat/Long point cannot follow an ATS route}}
\DoxyCodeLine{1379                 sub\_type = next\_token.get\_token\_sub\_type()}
\DoxyCodeLine{1380                 \textcolor{keywordflow}{if} sub\_type == TokenSubType.F15\_SB\_PRP\_BD \textcolor{keywordflow}{or} sub\_type == TokenSubType.F15\_SB\_LL\_DEG \textcolor{keywordflow}{or} \(\backslash\)}
\DoxyCodeLine{1381                     sub\_type == TokenSubType.F15\_SB\_LL\_MIN \textcolor{keywordflow}{or} sub\_type == TokenSubType.F15\_SB\_LLBD\_DEG \textcolor{keywordflow}{or} \(\backslash\)}
\DoxyCodeLine{1382                         sub\_type == TokenSubType.F15\_SB\_LLBD\_MIN:}
\DoxyCodeLine{1383                     self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 48)}
\DoxyCodeLine{1384                 self.point(ers, tokens, next\_token)}
\DoxyCodeLine{1385             case TokenBaseType.F15\_ROUTE:}
\DoxyCodeLine{1386                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 53)}
\DoxyCodeLine{1387             case TokenBaseType.F15\_SID\_STAR | TokenBaseType.F15\_STAR:}
\DoxyCodeLine{1388                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 54)}
\DoxyCodeLine{1389             case TokenBaseType.F15\_SPEED\_ALTITUDE\_ALTITUDE | TokenBaseType.F15\_SPEED\_ALTITUDE\_PLUS:}
\DoxyCodeLine{1390                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 9)}
\DoxyCodeLine{1391             case TokenBaseType.F15\_TOO\_LONG:}
\DoxyCodeLine{1392                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 4)}
\DoxyCodeLine{1393             case TokenBaseType.F15\_STAY\_TIME:}
\DoxyCodeLine{1394                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 10)}
\DoxyCodeLine{1395             case TokenBaseType.F15\_SID:}
\DoxyCodeLine{1396                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 30)}
\DoxyCodeLine{1397             case \_:}
\DoxyCodeLine{1398                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 0)}
\DoxyCodeLine{1399 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a72aa215575e0603bbb125b150c1b6895}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a72aa215575e0603bbb125b150c1b6895}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!set\_azimuth\_and\_distance@{set\_azimuth\_and\_distance}}
\index{set\_azimuth\_and\_distance@{set\_azimuth\_and\_distance}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{set\_azimuth\_and\_distance()}{set\_azimuth\_and\_distance()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+set\+\_\+azimuth\+\_\+and\+\_\+distance (\begin{DoxyParamCaption}\item[{}]{point\+\_\+1,  }\item[{}]{point\+\_\+2 }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyVerb}This method sets a bearing / azimuth and distance from a point 'point_1' to point 'point_2'.

:param point_1: The point that will have the bearing / azimuth and distance set that provides the
       azimuth and distance from this point to point_2.
:param point_2: The second point to calculate the azimuth and distance to.
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1401     \textcolor{keyword}{def }set\_azimuth\_and\_distance(point\_1, point\_2):}
\DoxyCodeLine{1402         \textcolor{comment}{\# type: (ExtractedRouteRecord, ExtractedRouteRecord) -\/> None}}
\DoxyCodeLine{1403         \textcolor{stringliteral}{"""This method sets a bearing / azimuth and distance from a point 'point\_1' to point 'point\_2'.}}
\DoxyCodeLine{1404 \textcolor{stringliteral}{}}
\DoxyCodeLine{1405 \textcolor{stringliteral}{        :param point\_1: The point that will have the bearing / azimuth and distance set that provides the}}
\DoxyCodeLine{1406 \textcolor{stringliteral}{               azimuth and distance from this point to point\_2.}}
\DoxyCodeLine{1407 \textcolor{stringliteral}{        :param point\_2: The second point to calculate the azimuth and distance to.}}
\DoxyCodeLine{1408 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1409 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1410         azimuth\_distance = Utils().get\_bearing\_distance\_between\_points(}
\DoxyCodeLine{1411             point\_1.get\_latitude(), point\_1.get\_longitude(),}
\DoxyCodeLine{1412             point\_2.get\_latitude(), point\_2.get\_longitude())}
\DoxyCodeLine{1413         point\_1.set\_bearing(azimuth\_distance[0])}
\DoxyCodeLine{1414         point\_1.set\_distance(azimuth\_distance[1])}
\DoxyCodeLine{1415 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a1582693ea36dc4d0ab65f01c9dc35134}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a1582693ea36dc4d0ab65f01c9dc35134}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!sid@{sid}}
\index{sid@{sid}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{sid()}{sid()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+sid (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes an SID token that must be the token following the ADEP. Any other location
in field 15 will result in an error.

:param ers: An ExtractedRouteSequence class instance containing only the ADEP (no error case) or any
       other element type (error case) record in the last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: An SID token being appended to the ERS;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1416     \textcolor{keyword}{def }sid(self, ers, tokens, token):}
\DoxyCodeLine{1417         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{1418         \textcolor{stringliteral}{"""This method processes an SID token that must be the token following the ADEP. Any other location}}
\DoxyCodeLine{1419 \textcolor{stringliteral}{        in field 15 will result in an error.}}
\DoxyCodeLine{1420 \textcolor{stringliteral}{}}
\DoxyCodeLine{1421 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing only the ADEP (no error case) or any}}
\DoxyCodeLine{1422 \textcolor{stringliteral}{               other element type (error case) record in the last ERS record.}}
\DoxyCodeLine{1423 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1424 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1425 \textcolor{stringliteral}{        :param token: An SID token being appended to the ERS;}}
\DoxyCodeLine{1426 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1427 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1428         self.add\_record(ers, token)}
\DoxyCodeLine{1429 }
\DoxyCodeLine{1430         \textcolor{comment}{\# The SID must be the second record in the ERS following the ADEP}}
\DoxyCodeLine{1431         \textcolor{keywordflow}{if} ers.get\_number\_of\_elements() == 2:}
\DoxyCodeLine{1432             sid\_rec = ers.get\_element\_at(1)}
\DoxyCodeLine{1433             \textcolor{keywordflow}{if} sid\_rec.get\_name() == \textcolor{stringliteral}{"SID"}:}
\DoxyCodeLine{1434                 sid\_rec.set\_base\_type(TokenBaseType.F15\_SID)}
\DoxyCodeLine{1435                 sid\_rec.set\_sub\_type(TokenSubType.F15\_SB\_SID\_LITERAL)}
\DoxyCodeLine{1436             \textcolor{keywordflow}{else}:}
\DoxyCodeLine{1437                 sid\_rec.set\_base\_type(TokenBaseType.F15\_SID)}
\DoxyCodeLine{1438                 sid\_rec.set\_sub\_type(TokenSubType.F15\_SB\_SID)}
\DoxyCodeLine{1439             self.post\_sid(ers, tokens)}
\DoxyCodeLine{1440         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{1441             self.add\_error\_and\_re\_sync(ers, tokens, token, 30)}
\DoxyCodeLine{1442 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a43ab56dde6cc24f1598bf28147df03ad}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a43ab56dde6cc24f1598bf28147df03ad}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!sid\_star@{sid\_star}}
\index{sid\_star@{sid\_star}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{sid\_star()}{sid\_star()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+sid\+\_\+star (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes an element which matches the syntax for both a SID or STAR element; the
syntax cannot be used to uniquely identify which element type it is. The exact type can only be
determined by its position in field 15. The SID must be the first token in the list of tokens and
the STAR the last. If the element appears anywhere else in the token list it is an error.

:param ers: An ExtractedRouteSequence class instance containing only the ADEP or an IFR element that
       is assumed to be the penultimate element in field 15 as the last ERS record (no error case)
       or the SID/STAR element is in the middle of the field 15 token list (error case).
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: An SID or STAR token being appended to the ERS;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1443     \textcolor{keyword}{def }sid\_star(self, ers, tokens, token):}
\DoxyCodeLine{1444         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{1445         \textcolor{stringliteral}{"""This method processes an element which matches the syntax for both a SID or STAR element; the}}
\DoxyCodeLine{1446 \textcolor{stringliteral}{        syntax cannot be used to uniquely identify which element type it is. The exact type can only be}}
\DoxyCodeLine{1447 \textcolor{stringliteral}{        determined by its position in field 15. The SID must be the first token in the list of tokens and}}
\DoxyCodeLine{1448 \textcolor{stringliteral}{        the STAR the last. If the element appears anywhere else in the token list it is an error.}}
\DoxyCodeLine{1449 \textcolor{stringliteral}{}}
\DoxyCodeLine{1450 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing only the ADEP or an IFR element that}}
\DoxyCodeLine{1451 \textcolor{stringliteral}{               is assumed to be the penultimate element in field 15 as the last ERS record (no error case)}}
\DoxyCodeLine{1452 \textcolor{stringliteral}{               or the SID/STAR element is in the middle of the field 15 token list (error case).}}
\DoxyCodeLine{1453 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1454 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1455 \textcolor{stringliteral}{        :param token: An SID or STAR token being appended to the ERS;}}
\DoxyCodeLine{1456 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1457 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1458         ex\_route\_rec = self.add\_record(ers, token)}
\DoxyCodeLine{1459 }
\DoxyCodeLine{1460         \textcolor{comment}{\# The SID must be the second record in the ERS following the ADEP}}
\DoxyCodeLine{1461         \textcolor{keywordflow}{if} ers.get\_number\_of\_elements() == 2:}
\DoxyCodeLine{1462             \textcolor{comment}{\# ERS record after the ADEP, so it must be a SID}}
\DoxyCodeLine{1463             \textcolor{keywordflow}{if} token.get\_token\_string() == \textcolor{stringliteral}{"SID"}:}
\DoxyCodeLine{1464                 ex\_route\_rec.set\_base\_type(TokenBaseType.F15\_SID)}
\DoxyCodeLine{1465                 ex\_route\_rec.set\_sub\_type(TokenSubType.F15\_SB\_SID\_LITERAL)}
\DoxyCodeLine{1466             \textcolor{keywordflow}{else}:}
\DoxyCodeLine{1467                 ex\_route\_rec.set\_base\_type(TokenBaseType.F15\_SID)}
\DoxyCodeLine{1468                 ex\_route\_rec.set\_sub\_type(TokenSubType.F15\_SB\_SID)}
\DoxyCodeLine{1469             \textcolor{comment}{\# Figure out which node to go to next}}
\DoxyCodeLine{1470             self.post\_sid(ers, tokens)}
\DoxyCodeLine{1471         \textcolor{keywordflow}{elif} tokens.peek\_next\_token(1) \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1472             \textcolor{comment}{\# No more tokens left so this must be the last token that}}
\DoxyCodeLine{1473             \textcolor{comment}{\# implies this is a STAR}}
\DoxyCodeLine{1474             \textcolor{keywordflow}{if} token.get\_token\_string() == \textcolor{stringliteral}{"STAR"}:}
\DoxyCodeLine{1475                 ex\_route\_rec.set\_base\_type(TokenBaseType.F15\_STAR)}
\DoxyCodeLine{1476                 ex\_route\_rec.set\_sub\_type(TokenSubType.F15\_SB\_STAR\_LITERAL)}
\DoxyCodeLine{1477             \textcolor{keywordflow}{else}:}
\DoxyCodeLine{1478                 ex\_route\_rec.set\_base\_type(TokenBaseType.F15\_STAR)}
\DoxyCodeLine{1479                 ex\_route\_rec.set\_sub\_type(TokenSubType.F15\_SB\_STAR)}
\DoxyCodeLine{1480         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{1481             self.add\_error\_and\_re\_sync(ers, tokens, tokens.peek\_next\_token(1), 34)}
\DoxyCodeLine{1482 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a59c8880b146d1f96747346d46df63496}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a59c8880b146d1f96747346d46df63496}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!star@{star}}
\index{star@{star}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{star()}{star()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+star (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes a STAR token that must be the last token in the list of tokens. Any other
location in field 15 will result in an error.

:param ers: An ExtractedRouteSequence class instance containing an IFR element as its last record
       that is assumed to be the penultimate element in field 15 (no error case) or the STAR element is
       in the middle of the field 15 token list (error case).
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: A STAR token being appended to the ERS;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1483     \textcolor{keyword}{def }star(self, ers, tokens, token):}
\DoxyCodeLine{1484         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{1485         \textcolor{stringliteral}{"""This method processes a STAR token that must be the last token in the list of tokens. Any other}}
\DoxyCodeLine{1486 \textcolor{stringliteral}{        location in field 15 will result in an error.}}
\DoxyCodeLine{1487 \textcolor{stringliteral}{}}
\DoxyCodeLine{1488 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing an IFR element as its last record}}
\DoxyCodeLine{1489 \textcolor{stringliteral}{               that is assumed to be the penultimate element in field 15 (no error case) or the STAR element is}}
\DoxyCodeLine{1490 \textcolor{stringliteral}{               in the middle of the field 15 token list (error case).}}
\DoxyCodeLine{1491 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1492 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1493 \textcolor{stringliteral}{        :param token: A STAR token being appended to the ERS;}}
\DoxyCodeLine{1494 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1495 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1496         ex\_route\_rec = self.add\_record(ers, token)}
\DoxyCodeLine{1497 }
\DoxyCodeLine{1498         \textcolor{comment}{\# The STAR must be the last record in the ERS}}
\DoxyCodeLine{1499         \textcolor{keywordflow}{if} tokens.peek\_next\_token(1) \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1500             \textcolor{comment}{\# No more tokens left so this must be the last token that}}
\DoxyCodeLine{1501             \textcolor{comment}{\# implies this is a STAR}}
\DoxyCodeLine{1502             \textcolor{keywordflow}{if} token.get\_token\_string() == \textcolor{stringliteral}{"STAR"}:}
\DoxyCodeLine{1503                 ex\_route\_rec.set\_base\_type(TokenBaseType.F15\_STAR)}
\DoxyCodeLine{1504                 ex\_route\_rec.set\_sub\_type(TokenSubType.F15\_SB\_STAR\_LITERAL)}
\DoxyCodeLine{1505             \textcolor{keywordflow}{else}:}
\DoxyCodeLine{1506                 ex\_route\_rec.set\_base\_type(TokenBaseType.F15\_STAR)}
\DoxyCodeLine{1507                 ex\_route\_rec.set\_sub\_type(TokenSubType.F15\_SB\_STAR)}
\DoxyCodeLine{1508         \textcolor{keywordflow}{else}:}
\DoxyCodeLine{1509             self.add\_error\_and\_re\_sync(ers, tokens, tokens.peek\_next\_token(1), 34)}
\DoxyCodeLine{1510 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_ae36246d517c0698b27dd1da6238fcf23}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_ae36246d517c0698b27dd1da6238fcf23}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!stay@{stay}}
\index{stay@{stay}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{stay()}{stay()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+stay (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes a STAY token that indicates a 'stay' time at an IFR point preceding the
STAY token. The method checks the correct token sequence, i.e. Stay -> '/' -> HHMM. Errors are
reported if the sequence is incorrect.

:param ers: An ExtractedRouteSequence class instance containing an IFR point element as its last ERS record.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: A STAY token being appended to the ERS;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1511     \textcolor{keyword}{def }stay(self, ers, tokens, token):}
\DoxyCodeLine{1512         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{1513         \textcolor{stringliteral}{"""This method processes a STAY token that indicates a 'stay' time at an IFR point preceding the}}
\DoxyCodeLine{1514 \textcolor{stringliteral}{        STAY token. The method checks the correct token sequence, i.e. Stay -\/> '/' -\/> HHMM. Errors are}}
\DoxyCodeLine{1515 \textcolor{stringliteral}{        reported if the sequence is incorrect.}}
\DoxyCodeLine{1516 \textcolor{stringliteral}{}}
\DoxyCodeLine{1517 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing an IFR point element as its last ERS record.}}
\DoxyCodeLine{1518 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1519 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1520 \textcolor{stringliteral}{        :param token: A STAY token being appended to the ERS;}}
\DoxyCodeLine{1521 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1522 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1523         \textcolor{comment}{\# The STAY token does not have to be stored,}}
\DoxyCodeLine{1524         \textcolor{comment}{\# skip it and get what should be a forward slash}}
\DoxyCodeLine{1525         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{1526         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1527             self.add\_error\_and\_re\_sync(ers, tokens, token, 35)}
\DoxyCodeLine{1528             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1529 }
\DoxyCodeLine{1530         \textcolor{comment}{\# The next token must be a forward slash}}
\DoxyCodeLine{1531         \textcolor{keywordflow}{if} next\_token.get\_token\_base\_type() \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} TokenBaseType.F15\_SLASH:}
\DoxyCodeLine{1532             self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 36)}
\DoxyCodeLine{1533             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1534 }
\DoxyCodeLine{1535         \textcolor{comment}{\# Skip the forward slash and get the HHMM token}}
\DoxyCodeLine{1536         current\_token = next\_token}
\DoxyCodeLine{1537         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{1538         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1539             self.add\_error\_and\_re\_sync(ers, tokens, current\_token, 37)}
\DoxyCodeLine{1540             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1541 }
\DoxyCodeLine{1542         \textcolor{comment}{\# The next token must be a HHMM token}}
\DoxyCodeLine{1543         current\_token = next\_token}
\DoxyCodeLine{1544         \textcolor{keywordflow}{if} next\_token.get\_token\_base\_type() \textcolor{keywordflow}{is} \textcolor{keywordflow}{not} TokenBaseType.F15\_STAY\_TIME:}
\DoxyCodeLine{1545             self.add\_error\_and\_re\_sync(ers, tokens, current\_token, 38)}
\DoxyCodeLine{1546             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1547 }
\DoxyCodeLine{1548         \textcolor{comment}{\# Process the HHMM token}}
\DoxyCodeLine{1549         self.stay\_time(ers, tokens, next\_token)}
\DoxyCodeLine{1550 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_afc4152cee2f5f5e4a88d2ec6228552a1}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_afc4152cee2f5f5e4a88d2ec6228552a1}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!stay\_time@{stay\_time}}
\index{stay\_time@{stay\_time}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{stay\_time()}{stay\_time()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+stay\+\_\+time (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens,  }\item[{}]{token }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes a stay HHMM token that provides the duration at a 'stay' point. The method
saves the HHMM token to the ERS and determines the next processing node after the HHMM TOKEN.

:param ers: An ExtractedRouteSequence class instance containing an IFR point element as its last ERS
       record on which the stay time will be stored in minutes.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:param token: A stay HHMM token being saved on the last ERS point record;
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1551     \textcolor{keyword}{def }stay\_time(self, ers, tokens, token):}
\DoxyCodeLine{1552         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens, Token) -\/> None}}
\DoxyCodeLine{1553         \textcolor{stringliteral}{"""This method processes a stay HHMM token that provides the duration at a 'stay' point. The method}}
\DoxyCodeLine{1554 \textcolor{stringliteral}{        saves the HHMM token to the ERS and determines the next processing node after the HHMM TOKEN.}}
\DoxyCodeLine{1555 \textcolor{stringliteral}{}}
\DoxyCodeLine{1556 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing an IFR point element as its last ERS}}
\DoxyCodeLine{1557 \textcolor{stringliteral}{               record on which the stay time will be stored in minutes.}}
\DoxyCodeLine{1558 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1559 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1560 \textcolor{stringliteral}{        :param token: A stay HHMM token being saved on the last ERS point record;}}
\DoxyCodeLine{1561 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1562 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1563         \textcolor{comment}{\# Save the HHMM token to the previous ERS element, which must be a point}}
\DoxyCodeLine{1564         ers.get\_last\_element().set\_stay\_time(token.get\_token\_string())}
\DoxyCodeLine{1565 }
\DoxyCodeLine{1566         \textcolor{comment}{\# Get the next token}}
\DoxyCodeLine{1567         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{1568         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1569             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1570 }
\DoxyCodeLine{1571         \textcolor{comment}{\# Determine the next node}}
\DoxyCodeLine{1572         base\_type = next\_token.get\_token\_base\_type()}
\DoxyCodeLine{1573         match base\_type:}
\DoxyCodeLine{1574             case TokenBaseType.F15\_UNKNOWN:}
\DoxyCodeLine{1575                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 3)}
\DoxyCodeLine{1576             case TokenBaseType.F15\_BREAK\_START:}
\DoxyCodeLine{1577                 self.break\_start(ers, tokens, next\_token)}
\DoxyCodeLine{1578             case TokenBaseType.F15\_BREAK\_END:}
\DoxyCodeLine{1579                 self.break\_end\_error(ers, tokens, next\_token)}
\DoxyCodeLine{1580             case TokenBaseType.F15\_DCT:}
\DoxyCodeLine{1581                 self.dct(ers, tokens, next\_token)}
\DoxyCodeLine{1582             case TokenBaseType.F15\_TRUNCATE:}
\DoxyCodeLine{1583                 self.truncate(ers, tokens)}
\DoxyCodeLine{1584             case TokenBaseType.F15\_C:}
\DoxyCodeLine{1585                 self.cruise\_climb\_c(ers, tokens, next\_token)}
\DoxyCodeLine{1586             case TokenBaseType.F15\_POINT:}
\DoxyCodeLine{1587                 self.point(ers, tokens, next\_token)}
\DoxyCodeLine{1588             case TokenBaseType.F15\_ROUTE:}
\DoxyCodeLine{1589                 self.route(ers, tokens, next\_token)}
\DoxyCodeLine{1590             case TokenBaseType.F15\_SID\_STAR:}
\DoxyCodeLine{1591                 self.sid\_star(ers, tokens, next\_token)}
\DoxyCodeLine{1592             case TokenBaseType.F15\_TOO\_LONG:}
\DoxyCodeLine{1593                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 4)}
\DoxyCodeLine{1594             case TokenBaseType.F15\_SID:}
\DoxyCodeLine{1595                 self.sid(ers, tokens, next\_token)}
\DoxyCodeLine{1596             case TokenBaseType.F15\_STAR:}
\DoxyCodeLine{1597                 self.star(ers, tokens, next\_token)}
\DoxyCodeLine{1598             case \_:}
\DoxyCodeLine{1599                 \textcolor{comment}{\# TokenBaseType.F15\_SLASH | TokenBaseType.F15\_SPEED\_VFR |}}
\DoxyCodeLine{1600                 \textcolor{comment}{\# TokenBaseType.F15\_SPEED\_ALTITUDE | TokenBaseType.F15\_STAY |}}
\DoxyCodeLine{1601                 \textcolor{comment}{\# TokenBaseType.F15\_SPEED\_ALTITUDE\_ALTITUDE | TokenBaseType.F15\_SPEED\_ALTITUDE\_PLUS |}}
\DoxyCodeLine{1602                 \textcolor{comment}{\# TokenBaseType.F15\_STAY\_TIME}}
\DoxyCodeLine{1603                 self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 39)}
\DoxyCodeLine{1604 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_aed2d2aab33d5f863b42278fb8cd4c902}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_aed2d2aab33d5f863b42278fb8cd4c902}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!truncate@{truncate}}
\index{truncate@{truncate}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{truncate()}{truncate()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+truncate (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes the 'T' truncate field 15 token. The 'T' character indicates that the
field 15 has been truncated. No elements should occur after this element. The 'T' is not saved
to the ERS. If there are any other tokens following the 'T' an error is reported.

:param ers: An ExtractedRouteSequence class instance containing the last processed element
       irrespective of its type.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:return: A token being processed to determine if field 15 is being correctly truncated;
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1605     \textcolor{keyword}{def }truncate(self, ers, tokens):}
\DoxyCodeLine{1606         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens) -\/> None}}
\DoxyCodeLine{1607         \textcolor{stringliteral}{"""This method processes the 'T' truncate field 15 token. The 'T' character indicates that the}}
\DoxyCodeLine{1608 \textcolor{stringliteral}{        field 15 has been truncated. No elements should occur after this element. The 'T' is not saved}}
\DoxyCodeLine{1609 \textcolor{stringliteral}{        to the ERS. If there are any other tokens following the 'T' an error is reported.}}
\DoxyCodeLine{1610 \textcolor{stringliteral}{}}
\DoxyCodeLine{1611 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance containing the last processed element}}
\DoxyCodeLine{1612 \textcolor{stringliteral}{               irrespective of its type.}}
\DoxyCodeLine{1613 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1614 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1615 \textcolor{stringliteral}{        :return: A token being processed to determine if field 15 is being correctly truncated;}}
\DoxyCodeLine{1616 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1617         next\_token = tokens.get\_next\_token()}
\DoxyCodeLine{1618         \textcolor{keywordflow}{if} next\_token \textcolor{keywordflow}{is} \textcolor{keywordtype}{None}:}
\DoxyCodeLine{1619             \textcolor{keywordflow}{return}}
\DoxyCodeLine{1620         self.add\_error\_and\_re\_sync(ers, tokens, next\_token, 19)}
\DoxyCodeLine{1621 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a8c47c48bf172e65d95917d2dffefe880}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a8c47c48bf172e65d95917d2dffefe880}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!v\_to\_i\_rule\_change@{v\_to\_i\_rule\_change}}
\index{v\_to\_i\_rule\_change@{v\_to\_i\_rule\_change}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{v\_to\_i\_rule\_change()}{v\_to\_i\_rule\_change()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+v\+\_\+to\+\_\+i\+\_\+rule\+\_\+change (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method executes a rule change from VFR to IFR. To complete this rule change there has to be
a point, a slash '/' and a SPEED/LEVEL following the IFR rule change element. The method break_end()
performs a look-ahead from the IFR token to ensure these tokens are present and then calls this method.

This method assumes all the required tokens are available in the Tokens list to copy the rule
change elements to the ERS.

:param ers: An ExtractedRouteSequence class instance with the last record containing the VFR item
       onto which all and any break text are copied.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1622     \textcolor{keyword}{def }v\_to\_i\_rule\_change(self, ers, tokens):}
\DoxyCodeLine{1623         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens) -\/> None}}
\DoxyCodeLine{1624         \textcolor{stringliteral}{"""This method executes a rule change from VFR to IFR. To complete this rule change there has to be}}
\DoxyCodeLine{1625 \textcolor{stringliteral}{        a point, a slash '/' and a SPEED/LEVEL following the IFR rule change element. The method break\_end()}}
\DoxyCodeLine{1626 \textcolor{stringliteral}{        performs a look-\/ahead from the IFR token to ensure these tokens are present and then calls this method.}}
\DoxyCodeLine{1627 \textcolor{stringliteral}{}}
\DoxyCodeLine{1628 \textcolor{stringliteral}{        This method assumes all the required tokens are available in the Tokens list to copy the rule}}
\DoxyCodeLine{1629 \textcolor{stringliteral}{        change elements to the ERS.}}
\DoxyCodeLine{1630 \textcolor{stringliteral}{}}
\DoxyCodeLine{1631 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance with the last record containing the VFR item}}
\DoxyCodeLine{1632 \textcolor{stringliteral}{               onto which all and any break text are copied.}}
\DoxyCodeLine{1633 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1634 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1635 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1636 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1637         \textcolor{comment}{\# Get the point for the rule change}}
\DoxyCodeLine{1638         token = tokens.get\_next\_token()}
\DoxyCodeLine{1639         ex\_route\_rec = self.add\_record(ers, token)}
\DoxyCodeLine{1640 }
\DoxyCodeLine{1641         \textcolor{comment}{\# Check lat/long and bearing distance semantics}}
\DoxyCodeLine{1642         \textcolor{keywordflow}{if} token.get\_token\_sub\_type() != TokenSubType.F15\_SB\_PRP \textcolor{keywordflow}{and} \(\backslash\)}
\DoxyCodeLine{1643                 token.get\_token\_sub\_type() != TokenSubType.F15\_SB\_PRP\_AERO:}
\DoxyCodeLine{1644             self.assign\_lat\_long\_bearing\_distance(ers, token)}
\DoxyCodeLine{1645 }
\DoxyCodeLine{1646         \textcolor{comment}{\# As this rule change is VFR to IFR and this is a speed altitude element,}}
\DoxyCodeLine{1647         \textcolor{comment}{\# the rules must be IFR}}
\DoxyCodeLine{1648         ex\_route\_rec.set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"I"}])}
\DoxyCodeLine{1649 }
\DoxyCodeLine{1650         \textcolor{comment}{\# Next comes the '/' token, skip this as this is not saved}}
\DoxyCodeLine{1651         tokens.get\_next\_token()}
\DoxyCodeLine{1652 }
\DoxyCodeLine{1653         \textcolor{comment}{\# Now comes the SPEED/ALTITUDE token}}
\DoxyCodeLine{1654         token = tokens.get\_next\_token()}
\DoxyCodeLine{1655         self.assign\_speed\_altitude(ers, tokens, token)}
\DoxyCodeLine{1656 }

\end{DoxyCode}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a4c5fde73ce1659f0048053fd9eb71576}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a4c5fde73ce1659f0048053fd9eb71576}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!v\_to\_i\_to\_v\_rule\_change@{v\_to\_i\_to\_v\_rule\_change}}
\index{v\_to\_i\_to\_v\_rule\_change@{v\_to\_i\_to\_v\_rule\_change}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{v\_to\_i\_to\_v\_rule\_change()}{v\_to\_i\_to\_v\_rule\_change()}}
{\footnotesize\ttfamily def F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+v\+\_\+to\+\_\+i\+\_\+to\+\_\+v\+\_\+rule\+\_\+change (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{ers,  }\item[{}]{tokens }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method processes a rule change from VFR to IFR occurs but the IFR point changes back to VFR,
i.e. a single point IFR section. This method executes a rule change from VFR to IFR and back to VFR.
To complete this rule change there has to be a point, a slash '/' and a SPEED/VFR following the IFR
rule change element. The method break_end() performs a look-ahead from the IFR token to ensure
these tokens are present and then calls this method.

This method assumes all the required tokens are available in the Tokens list to copy the rule change
elements to the ERS.

:param ers: An ExtractedRouteSequence class instance with the last record containing the VFR item
       onto which all and any break text are copied.
:param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure
       contains a tokenized form of all field 15 tokens used as input to this parser.
:return: None
\end{DoxyVerb}
 
\begin{DoxyCode}{0}
\DoxyCodeLine{1657     \textcolor{keyword}{def }v\_to\_i\_to\_v\_rule\_change(self, ers, tokens):}
\DoxyCodeLine{1658         \textcolor{comment}{\# type: (ExtractedRouteSequence, Tokens) -\/> None}}
\DoxyCodeLine{1659         \textcolor{stringliteral}{"""This method processes a rule change from VFR to IFR occurs but the IFR point changes back to VFR,}}
\DoxyCodeLine{1660 \textcolor{stringliteral}{        i.e. a single point IFR section. This method executes a rule change from VFR to IFR and back to VFR.}}
\DoxyCodeLine{1661 \textcolor{stringliteral}{        To complete this rule change there has to be a point, a slash '/' and a SPEED/VFR following the IFR}}
\DoxyCodeLine{1662 \textcolor{stringliteral}{        rule change element. The method break\_end() performs a look-\/ahead from the IFR token to ensure}}
\DoxyCodeLine{1663 \textcolor{stringliteral}{        these tokens are present and then calls this method.}}
\DoxyCodeLine{1664 \textcolor{stringliteral}{}}
\DoxyCodeLine{1665 \textcolor{stringliteral}{        This method assumes all the required tokens are available in the Tokens list to copy the rule change}}
\DoxyCodeLine{1666 \textcolor{stringliteral}{        elements to the ERS.}}
\DoxyCodeLine{1667 \textcolor{stringliteral}{}}
\DoxyCodeLine{1668 \textcolor{stringliteral}{        :param ers: An ExtractedRouteSequence class instance with the last record containing the VFR item}}
\DoxyCodeLine{1669 \textcolor{stringliteral}{               onto which all and any break text are copied.}}
\DoxyCodeLine{1670 \textcolor{stringliteral}{        :param tokens: A list of tokens extracted from field 15 used as input to the parser. This structure}}
\DoxyCodeLine{1671 \textcolor{stringliteral}{               contains a tokenized form of all field 15 tokens used as input to this parser.}}
\DoxyCodeLine{1672 \textcolor{stringliteral}{        :return: None}}
\DoxyCodeLine{1673 \textcolor{stringliteral}{        """}}
\DoxyCodeLine{1674         \textcolor{comment}{\# Get the point for the rule change}}
\DoxyCodeLine{1675         token = tokens.get\_next\_token()}
\DoxyCodeLine{1676         ex\_route\_rec = self.add\_record(ers, token)}
\DoxyCodeLine{1677 }
\DoxyCodeLine{1678         \textcolor{comment}{\# As this rule change is VFR to IFR and this is a speed altitude element,}}
\DoxyCodeLine{1679         \textcolor{comment}{\# the rules must be IFR}}
\DoxyCodeLine{1680         ex\_route\_rec.set\_flight\_rules(self.RULES[\textcolor{stringliteral}{"I"}])}
\DoxyCodeLine{1681 }
\DoxyCodeLine{1682         \textcolor{comment}{\# Next comes the '/' token, skip this as this is not saved}}
\DoxyCodeLine{1683         tokens.get\_next\_token()}
\DoxyCodeLine{1684 }
\DoxyCodeLine{1685         \textcolor{comment}{\# Now comes the SPEED/VFR token}}
\DoxyCodeLine{1686         token = tokens.get\_next\_token()}
\DoxyCodeLine{1687         self.assign\_speed\_vfr(ers, tokens, token)}
\DoxyCodeLine{1688 }

\end{DoxyCode}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a58d59303946e17822706f9f9637553c4}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a58d59303946e17822706f9f9637553c4}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!DEFAULT\_ALTITUDE@{DEFAULT\_ALTITUDE}}
\index{DEFAULT\_ALTITUDE@{DEFAULT\_ALTITUDE}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{DEFAULT\_ALTITUDE}{DEFAULT\_ALTITUDE}}
{\footnotesize\ttfamily string F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+D\+E\+F\+A\+U\+L\+T\+\_\+\+A\+L\+T\+I\+T\+U\+DE = \char`\"{}F050\char`\"{}\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classF15__Parser_1_1F15Parse_1_1ParseF15_a1212f57385394f7b405000288bdee47f}\label{classF15__Parser_1_1F15Parse_1_1ParseF15_a1212f57385394f7b405000288bdee47f}} 
\index{F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}!RULES@{RULES}}
\index{RULES@{RULES}!F15\_Parser.F15Parse.ParseF15@{F15\_Parser.F15Parse.ParseF15}}
\doxysubsubsection{\texorpdfstring{RULES}{RULES}}
{\footnotesize\ttfamily dictionary F15\+\_\+\+Parser.\+F15\+Parse.\+Parse\+F15.\+R\+U\+L\+ES = \{\char`\"{}I\char`\"{}\+: \char`\"{}I\+FR\char`\"{}, \char`\"{}V\char`\"{}\+: \char`\"{}V\+FR\char`\"{}, \char`\"{}O\char`\"{}\+: \char`\"{}O\+AT\char`\"{}, \char`\"{}S\char`\"{}\+: \char`\"{}I\+F\+PS\char`\"{}\}\hspace{0.3cm}{\ttfamily [static]}}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
F15\+\_\+\+Parser/\mbox{\hyperlink{F15Parse_8py}{F15\+Parse.\+py}}\end{DoxyCompactItemize}
